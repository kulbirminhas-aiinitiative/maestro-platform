# Kubernetes Secrets Template
# IMPORTANT: This is an example file. DO NOT commit actual secrets to version control.
# Create the actual secrets using kubectl or a secrets management tool like Sealed Secrets or External Secrets Operator

apiVersion: v1
kind: Secret
metadata:
  name: user-api-secrets
  namespace: production
  labels:
    app: user-api
type: Opaque
stringData:
  # Database credentials
  db-host: "postgres.production.svc.cluster.local"
  db-user: "user_api_user"
  db-password: "CHANGE_ME_STRONG_PASSWORD"

  # Redis credentials
  redis-password: "CHANGE_ME_REDIS_PASSWORD"

  # JWT configuration
  jwt-secret: "CHANGE_ME_RANDOM_256_BIT_KEY"

  # Optional: External service API keys
  # email-api-key: "CHANGE_ME_EMAIL_SERVICE_KEY"
  # monitoring-api-key: "CHANGE_ME_MONITORING_KEY"

---
# Instructions for creating secrets in production:
#
# Option 1: Using kubectl (basic)
# kubectl create secret generic user-api-secrets \
#   --from-literal=db-host='your-db-host' \
#   --from-literal=db-user='your-db-user' \
#   --from-literal=db-password='your-strong-password' \
#   --from-literal=redis-password='your-redis-password' \
#   --from-literal=jwt-secret='your-jwt-secret' \
#   --namespace=production
#
# Option 2: Using Sealed Secrets (recommended for GitOps)
# 1. Install Sealed Secrets controller
# 2. Create a regular secret YAML
# 3. Seal it: kubeseal < secret.yaml > sealed-secret.yaml
# 4. Commit sealed-secret.yaml to git
#
# Option 3: Using External Secrets Operator (recommended for cloud)
# Integrate with AWS Secrets Manager, Azure Key Vault, GCP Secret Manager, etc.
#
# Option 4: HashiCorp Vault
# Use Vault Agent Injector for dynamic secret injection
