"""
EU AI Act Article 11 - Model Cards Documentation.

EPIC: MD-2159 - [Compliance] Technical Documentation
AC-4: Write model cards for each LLM integration

This module provides structures for creating model cards that
document LLM capabilities, limitations, and intended use cases.

AI DISCLOSURE: This code was generated by AI (Claude) for EU AI Act compliance purposes.
"""

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Dict, List, Optional, Any
import json


class ModelProvider(Enum):
    """LLM provider classification."""
    ANTHROPIC = "anthropic"
    OPENAI = "openai"
    GOOGLE = "google"
    META = "meta"
    MISTRAL = "mistral"
    COHERE = "cohere"
    CUSTOM = "custom"


class ModelCapability(Enum):
    """Capabilities of LLM models."""
    TEXT_GENERATION = "text_generation"
    CODE_GENERATION = "code_generation"
    SUMMARIZATION = "summarization"
    TRANSLATION = "translation"
    CLASSIFICATION = "classification"
    QUESTION_ANSWERING = "question_answering"
    REASONING = "reasoning"
    MULTIMODAL = "multimodal"


class BiasCategory(Enum):
    """Categories of potential bias."""
    GENDER = "gender"
    RACIAL = "racial"
    CULTURAL = "cultural"
    POLITICAL = "political"
    AGE = "age"
    SOCIOECONOMIC = "socioeconomic"
    LANGUAGE = "language"


@dataclass
class ModelMetrics:
    """Performance metrics for a model."""
    accuracy: Optional[float] = None
    precision: Optional[float] = None
    recall: Optional[float] = None
    f1_score: Optional[float] = None
    latency_ms: Optional[float] = None
    tokens_per_second: Optional[float] = None
    custom_metrics: Dict[str, float] = field(default_factory=dict)


@dataclass
class BiasAssessment:
    """Assessment of potential biases in the model."""
    category: BiasCategory
    assessed: bool
    findings: str
    mitigation_applied: str
    residual_risk: str


@dataclass
class UsageGuideline:
    """Guidelines for model usage."""
    scenario: str
    recommended: bool
    rationale: str
    required_oversight: str


@dataclass
class ModelCard:
    """
    Complete Model Card per EU AI Act requirements.

    Model cards must document:
    - Model identity and purpose
    - Training data and methodology
    - Performance metrics
    - Limitations and biases
    - Intended and prohibited uses
    """
    id: str
    name: str
    version: str
    provider: ModelProvider
    description: str
    capabilities: List[ModelCapability]
    intended_use: str
    prohibited_uses: List[str]
    training_data_summary: str
    training_methodology: str
    metrics: ModelMetrics
    limitations: List[str]
    bias_assessments: List[BiasAssessment]
    usage_guidelines: List[UsageGuideline]
    human_oversight_requirements: List[str]
    update_frequency: str
    contact_info: str
    created_at: datetime
    updated_at: datetime
    author: str


class ModelCardRegistry:
    """
    Registry for managing model cards.

    Per EU AI Act Article 11, model documentation must include:
    - Description of the AI system
    - Detailed description of development process
    - Information on monitoring and control
    - Accuracy levels and known limitations
    """

    def __init__(self):
        self.model_cards: Dict[str, ModelCard] = {}

    def register_model_card(self, card: ModelCard) -> bool:
        """Register a new model card."""
        if card.id in self.model_cards:
            return False
        self.model_cards[card.id] = card
        return True

    def get_model_card(self, card_id: str) -> Optional[ModelCard]:
        """Retrieve a model card by ID."""
        return self.model_cards.get(card_id)

    def update_model_card(self, card_id: str, updates: Dict[str, Any]) -> bool:
        """Update an existing model card."""
        if card_id not in self.model_cards:
            return False

        card = self.model_cards[card_id]
        for key, value in updates.items():
            if hasattr(card, key):
                setattr(card, key, value)
        card.updated_at = datetime.utcnow()
        return True

    def list_model_cards(self, provider: Optional[ModelProvider] = None) -> List[ModelCard]:
        """List all model cards, optionally filtered by provider."""
        cards = list(self.model_cards.values())
        if provider:
            cards = [c for c in cards if c.provider == provider]
        return cards

    def get_models_with_capability(self, capability: ModelCapability) -> List[ModelCard]:
        """Get models with a specific capability."""
        return [
            c for c in self.model_cards.values()
            if capability in c.capabilities
        ]

    def validate_model_card_completeness(self, card_id: str) -> Dict[str, Any]:
        """Validate model card completeness per EU AI Act requirements."""
        card = self.model_cards.get(card_id)
        if not card:
            return {"valid": False, "errors": ["Model card not found"]}

        issues = []

        # Required fields validation
        if not card.description or len(card.description) < 100:
            issues.append("Description too short (min 100 chars for EU AI Act compliance)")

        if not card.intended_use:
            issues.append("Intended use not documented")

        if len(card.prohibited_uses) == 0:
            issues.append("Prohibited uses not documented")

        if not card.training_data_summary:
            issues.append("Training data summary missing")

        if len(card.limitations) == 0:
            issues.append("Limitations not documented")

        if len(card.bias_assessments) == 0:
            issues.append("Bias assessments not completed")

        # Check all bias categories assessed
        assessed_categories = {ba.category for ba in card.bias_assessments if ba.assessed}
        missing_categories = set(BiasCategory) - assessed_categories
        if missing_categories:
            issues.append(f"Bias categories not assessed: {[c.value for c in missing_categories]}")

        if len(card.human_oversight_requirements) == 0:
            issues.append("Human oversight requirements not documented")

        if not card.contact_info:
            issues.append("Contact information missing")

        return {
            "valid": len(issues) == 0,
            "card_id": card_id,
            "issues": issues,
            "completeness_score": max(0, 100 - len(issues) * 10)
        }

    def get_bias_summary(self) -> Dict[str, Any]:
        """Get summary of bias assessments across all models."""
        total_assessments = 0
        mitigated_count = 0
        unassessed_categories = set()

        for card in self.model_cards.values():
            for assessment in card.bias_assessments:
                total_assessments += 1
                if assessment.mitigation_applied and assessment.mitigation_applied != "None":
                    mitigated_count += 1

            assessed = {a.category for a in card.bias_assessments if a.assessed}
            unassessed_categories.update(set(BiasCategory) - assessed)

        return {
            "total_models": len(self.model_cards),
            "total_bias_assessments": total_assessments,
            "mitigations_applied": mitigated_count,
            "unassessed_categories": [c.value for c in unassessed_categories]
        }

    def generate_compliance_report(self) -> Dict[str, Any]:
        """Generate compliance report for all model cards."""
        results = []
        for card_id in self.model_cards:
            validation = self.validate_model_card_completeness(card_id)
            results.append(validation)

        total = len(results)
        compliant = sum(1 for r in results if r["valid"])

        return {
            "total_models": total,
            "compliant": compliant,
            "non_compliant": total - compliant,
            "compliance_rate": (compliant / total * 100) if total > 0 else 0,
            "bias_summary": self.get_bias_summary(),
            "details": results,
            "generated_at": datetime.utcnow().isoformat()
        }

    def export_to_json(self) -> str:
        """Export all model cards to JSON."""
        data = []
        for card in self.model_cards.values():
            data.append({
                "id": card.id,
                "name": card.name,
                "version": card.version,
                "provider": card.provider.value,
                "capabilities": [c.value for c in card.capabilities],
                "intended_use": card.intended_use,
                "prohibited_uses": card.prohibited_uses,
                "limitations": card.limitations,
                "bias_assessments": [
                    {"category": ba.category.value, "assessed": ba.assessed, "findings": ba.findings}
                    for ba in card.bias_assessments
                ],
                "human_oversight": card.human_oversight_requirements,
                "metrics": {
                    "accuracy": card.metrics.accuracy,
                    "latency_ms": card.metrics.latency_ms
                } if card.metrics else {}
            })
        return json.dumps({"model_cards": data, "count": len(data)}, indent=2)


def create_model_card_registry() -> ModelCardRegistry:
    """Factory function to create a ModelCardRegistry."""
    return ModelCardRegistry()
