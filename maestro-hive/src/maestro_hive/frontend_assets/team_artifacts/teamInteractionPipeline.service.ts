/**
 * MD-2371: Team Interaction Pipeline Service
 * Implements AC-4: Team Interaction Pipeline (hook into mission completion)
 *
 * Hooks into mission.service.ts completeMission() to trigger document generation.
 */

import {
  MissionContext,
  MissionParticipant,
  MissionMessage,
  MissionArtifact,
  DocumentGenerationResult,
  DocumentGenerationOptions,
} from './types';
import { missionDocumentGenerationService } from './missionDocumentGeneration.service';
import { personaDocumentConfigService } from './personaDocumentConfig.service';

/**
 * Mission completion event data
 * This interface represents the data structure from mission.service.ts
 */
interface MissionCompletionEvent {
  missionId: string;
  teamId: string;
  objective: string;
  outcome: string;
  participants: Array<{
    id: string;
    personaId: string;
    personaName: string;
    role: string;
  }>;
  messages: Array<{
    id: string;
    participantId: string;
    content: string;
    timestamp: string;
    type: string;
  }>;
  artifacts: Array<{
    id: string;
    type: string;
    content: string;
    generatedBy: string;
    createdAt: string;
  }>;
  completedAt: string;
}

/**
 * Pipeline configuration options
 */
interface PipelineConfig {
  enabled: boolean;
  autoGenerateDocuments: boolean;
  publishToConfluence: boolean;
  generateAiSummary: boolean;
  notifyOnComplete: boolean;
  allowedDocumentTypes?: string[];
}

/**
 * Service that connects mission completion to document generation
 */
export class TeamInteractionPipelineService {
  private config: PipelineConfig = {
    enabled: true,
    autoGenerateDocuments: true,
    publishToConfluence: true,
    generateAiSummary: true,
    notifyOnComplete: true,
  };

  private missionCallbacks: Map<string, (result: DocumentGenerationResult) => void> = new Map();

  /**
   * Hook that should be called by mission.service.ts when a mission completes
   * This is the integration point with the existing mission system
   */
  async onMissionComplete(event: MissionCompletionEvent): Promise<DocumentGenerationResult | null> {
    if (!this.config.enabled || !this.config.autoGenerateDocuments) {
      return null;
    }

    // Validate team has document generation capabilities
    const teamCapabilities = await personaDocumentConfigService.getTeamDocumentTypes(event.teamId);

    if (teamCapabilities.length === 0) {
      console.log(`Team ${event.teamId} has no document generation capabilities configured`);
      return null;
    }

    // Transform event data to mission context
    const missionContext = this.transformToMissionContext(event);

    // Build generation options from config
    const options: DocumentGenerationOptions = {
      publishToConfluence: this.config.publishToConfluence,
      generateAiSummary: this.config.generateAiSummary,
      notifyOnComplete: this.config.notifyOnComplete,
    };

    // Filter document types if configured
    if (this.config.allowedDocumentTypes) {
      options.templateOverrides = {};
      for (const type of teamCapabilities) {
        options.templateOverrides[type] = this.config.allowedDocumentTypes.includes(type);
      }
    }

    try {
      // Trigger document generation
      const result = await missionDocumentGenerationService.generateDocuments(
        missionContext,
        options
      );

      // Execute any registered callbacks
      const callback = this.missionCallbacks.get(event.missionId);
      if (callback) {
        callback(result);
        this.missionCallbacks.delete(event.missionId);
      }

      return result;
    } catch (error) {
      console.error(`Document generation failed for mission ${event.missionId}:`, error);
      throw error;
    }
  }

  /**
   * Register a callback to be called when document generation completes for a mission
   */
  onDocumentGenerationComplete(
    missionId: string,
    callback: (result: DocumentGenerationResult) => void
  ): void {
    this.missionCallbacks.set(missionId, callback);
  }

  /**
   * Manually trigger document generation for a completed mission
   * Useful for retrying or generating documents for historical missions
   */
  async triggerDocumentGeneration(
    missionId: string,
    teamId: string,
    options?: DocumentGenerationOptions
  ): Promise<DocumentGenerationResult> {
    // In a real implementation, this would fetch the mission data from the database
    const missionContext: MissionContext = {
      missionId,
      teamId,
      objective: 'Historical mission objective',
      outcome: 'Historical mission outcome',
      participants: [],
      messages: [],
      artifacts: [],
      completedAt: new Date(),
    };

    return missionDocumentGenerationService.generateDocuments(missionContext, options);
  }

  /**
   * Update pipeline configuration
   */
  updateConfig(config: Partial<PipelineConfig>): void {
    this.config = {
      ...this.config,
      ...config,
    };
  }

  /**
   * Get current pipeline configuration
   */
  getConfig(): PipelineConfig {
    return { ...this.config };
  }

  /**
   * Enable or disable the pipeline
   */
  setEnabled(enabled: boolean): void {
    this.config.enabled = enabled;
  }

  /**
   * Check if the pipeline is enabled
   */
  isEnabled(): boolean {
    return this.config.enabled;
  }

  /**
   * Pre-validate that a team can generate required documents
   */
  async validateTeamReadiness(
    teamId: string,
    requiredDocumentTypes: string[]
  ): Promise<{ ready: boolean; missing: string[]; message: string }> {
    const validation = await personaDocumentConfigService.validateTeamCapabilities(
      teamId,
      requiredDocumentTypes as any
    );

    if (validation.valid) {
      return {
        ready: true,
        missing: [],
        message: 'Team is ready for document generation',
      };
    }

    return {
      ready: false,
      missing: validation.missing,
      message: `Team is missing capabilities for: ${validation.missing.join(', ')}`,
    };
  }

  /**
   * Get statistics about pipeline processing
   */
  async getPipelineStats(): Promise<{
    enabled: boolean;
    totalMissionsProcessed: number;
    pendingCallbacks: number;
  }> {
    return {
      enabled: this.config.enabled,
      totalMissionsProcessed: 0, // Would track in production
      pendingCallbacks: this.missionCallbacks.size,
    };
  }

  private transformToMissionContext(event: MissionCompletionEvent): MissionContext {
    const participants: MissionParticipant[] = event.participants.map((p) => ({
      id: p.id,
      personaId: p.personaId,
      personaName: p.personaName,
      personaRole: this.normalizeRole(p.role),
    }));

    const messages: MissionMessage[] = event.messages.map((m) => ({
      id: m.id,
      participantId: m.participantId,
      content: m.content,
      timestamp: new Date(m.timestamp),
      messageType: this.normalizeMessageType(m.type),
    }));

    const artifacts: MissionArtifact[] = event.artifacts.map((a) => ({
      id: a.id,
      type: a.type,
      content: a.content,
      generatedBy: a.generatedBy,
      createdAt: new Date(a.createdAt),
    }));

    return {
      missionId: event.missionId,
      teamId: event.teamId,
      objective: event.objective,
      outcome: event.outcome,
      participants,
      messages,
      artifacts,
      completedAt: new Date(event.completedAt),
    };
  }

  private normalizeRole(role: string): MissionParticipant['personaRole'] {
    const roleMap: Record<string, MissionParticipant['personaRole']> = {
      'product manager': 'product_manager',
      'software architect': 'software_architect',
      'qa engineer': 'qa_engineer',
      'devops engineer': 'devops_engineer',
      'frontend developer': 'frontend_developer',
      'backend developer': 'backend_developer',
      'ux designer': 'ux_designer',
    };

    const normalizedRole = role.toLowerCase();
    return roleMap[normalizedRole] || 'backend_developer';
  }

  private normalizeMessageType(type: string): MissionMessage['messageType'] {
    const typeMap: Record<string, MissionMessage['messageType']> = {
      contribution: 'contribution',
      question: 'question',
      answer: 'answer',
      decision: 'decision',
    };

    return typeMap[type.toLowerCase()] || 'contribution';
  }
}

// Singleton instance
export const teamInteractionPipelineService = new TeamInteractionPipelineService();

/**
 * Integration function to be called from mission.service.ts
 * Add this to the completeMission function:
 *
 * import { onMissionComplete } from './teamInteractionPipeline.service';
 *
 * async completeMission(missionId: string) {
 *   // ... existing completion logic ...
 *
 *   // Trigger document generation pipeline
 *   await onMissionComplete({
 *     missionId,
 *     teamId: mission.teamId,
 *     objective: mission.objective,
 *     outcome: mission.outcome,
 *     participants: mission.participants,
 *     messages: mission.messages,
 *     artifacts: mission.artifacts,
 *     completedAt: new Date().toISOString(),
 *   });
 * }
 */
export const onMissionComplete = teamInteractionPipelineService.onMissionComplete.bind(
  teamInteractionPipelineService
);
