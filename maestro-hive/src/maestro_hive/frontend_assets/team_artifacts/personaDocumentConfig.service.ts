/**
 * MD-2371: Persona Document Configuration Service
 * Implements AC-1: Persona Document Configuration (schema + seeds)
 *
 * Maps personas to document types they can generate based on their role.
 */

import {
  TeamArtifactConfig,
  DocumentType,
  PersonaRole,
} from './types';

/**
 * Default persona-to-document type mappings
 * Based on typical role responsibilities
 */
const DEFAULT_PERSONA_DOCUMENT_MAPPINGS: Record<PersonaRole, DocumentType[]> = {
  product_manager: ['prd', 'userStories'],
  software_architect: ['techDesign', 'adr'],
  qa_engineer: ['testPlan'],
  devops_engineer: ['runbook', 'deploymentGuide'],
  frontend_developer: ['techDesign'],
  backend_developer: ['techDesign', 'adr'],
  ux_designer: ['prd', 'userStories'],
};

/**
 * Service for managing persona document configurations
 */
export class PersonaDocumentConfigService {
  private configs: Map<string, TeamArtifactConfig> = new Map();

  /**
   * Get document types for a specific persona role
   */
  getDocumentTypesForRole(role: PersonaRole): DocumentType[] {
    return DEFAULT_PERSONA_DOCUMENT_MAPPINGS[role] || [];
  }

  /**
   * Get configuration for a specific team and persona
   */
  async getConfig(teamId: string, personaId: string): Promise<TeamArtifactConfig | null> {
    const key = `${teamId}:${personaId}`;
    return this.configs.get(key) || null;
  }

  /**
   * Get all configurations for a team
   */
  async getTeamConfigs(teamId: string): Promise<TeamArtifactConfig[]> {
    const teamConfigs: TeamArtifactConfig[] = [];
    for (const config of this.configs.values()) {
      if (config.teamId === teamId && config.enabled) {
        teamConfigs.push(config);
      }
    }
    return teamConfigs;
  }

  /**
   * Create or update a persona document configuration
   */
  async upsertConfig(config: Omit<TeamArtifactConfig, 'id' | 'createdAt' | 'updatedAt'>): Promise<TeamArtifactConfig> {
    const key = `${config.teamId}:${config.personaId}`;
    const existing = this.configs.get(key);

    const now = new Date();
    const fullConfig: TeamArtifactConfig = {
      id: existing?.id || this.generateId(),
      ...config,
      createdAt: existing?.createdAt || now,
      updatedAt: now,
    };

    this.configs.set(key, fullConfig);
    return fullConfig;
  }

  /**
   * Initialize default configurations for a team based on its members
   */
  async initializeTeamConfigs(
    teamId: string,
    members: Array<{ personaId: string; personaRole: PersonaRole }>
  ): Promise<TeamArtifactConfig[]> {
    const configs: TeamArtifactConfig[] = [];

    for (const member of members) {
      const documentTypes = this.getDocumentTypesForRole(member.personaRole);

      if (documentTypes.length > 0) {
        const config = await this.upsertConfig({
          teamId,
          personaId: member.personaId,
          personaRole: member.personaRole,
          documentTypes,
          enabled: true,
        });
        configs.push(config);
      }
    }

    return configs;
  }

  /**
   * Disable a specific configuration
   */
  async disableConfig(teamId: string, personaId: string): Promise<boolean> {
    const key = `${teamId}:${personaId}`;
    const config = this.configs.get(key);

    if (config) {
      config.enabled = false;
      config.updatedAt = new Date();
      this.configs.set(key, config);
      return true;
    }

    return false;
  }

  /**
   * Update template overrides for a configuration
   */
  async updateTemplateOverrides(
    teamId: string,
    personaId: string,
    overrides: Record<string, unknown>
  ): Promise<TeamArtifactConfig | null> {
    const key = `${teamId}:${personaId}`;
    const config = this.configs.get(key);

    if (config) {
      config.templateOverrides = {
        ...config.templateOverrides,
        ...overrides,
      };
      config.updatedAt = new Date();
      this.configs.set(key, config);
      return config;
    }

    return null;
  }

  /**
   * Get all document types that can be generated by a team
   */
  async getTeamDocumentTypes(teamId: string): Promise<DocumentType[]> {
    const configs = await this.getTeamConfigs(teamId);
    const documentTypes = new Set<DocumentType>();

    for (const config of configs) {
      for (const docType of config.documentTypes) {
        documentTypes.add(docType);
      }
    }

    return Array.from(documentTypes);
  }

  /**
   * Find personas that can generate a specific document type
   */
  async findPersonasForDocumentType(
    teamId: string,
    documentType: DocumentType
  ): Promise<TeamArtifactConfig[]> {
    const configs = await this.getTeamConfigs(teamId);
    return configs.filter((config) => config.documentTypes.includes(documentType));
  }

  /**
   * Validate that a team can generate all required document types
   */
  async validateTeamCapabilities(
    teamId: string,
    requiredDocumentTypes: DocumentType[]
  ): Promise<{ valid: boolean; missing: DocumentType[] }> {
    const availableTypes = await this.getTeamDocumentTypes(teamId);
    const missing = requiredDocumentTypes.filter(
      (type) => !availableTypes.includes(type)
    );

    return {
      valid: missing.length === 0,
      missing,
    };
  }

  private generateId(): string {
    return `config_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}

// Singleton instance
export const personaDocumentConfigService = new PersonaDocumentConfigService();
