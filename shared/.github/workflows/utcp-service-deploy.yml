name: UTCP Service Deployment

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'examples/utcp-demo/**'
      - 'packages/core-api/**'
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      service_name:
        description: 'Service to deploy (workflow-engine, intelligence-service, or all)'
        required: true
        default: 'all'
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - development
          - staging
          - production

env:
  PYTHON_VERSION: "3.11"
  POETRY_VERSION: "2.2.1"
  REGISTRY_URL: "http://localhost:9000"  # UTCP Registry endpoint
  DOCKER_REGISTRY: "ghcr.io"

jobs:
  # Job 1: Build and Test UTCP Services
  build-test:
    name: Build & Test UTCP Service
    runs-on: ubuntu-latest

    strategy:
      matrix:
        service:
          - name: workflow-engine
            port: 8001
            path: examples/utcp-demo/workflow_service.py
          - name: intelligence-service
            port: 8002
            path: examples/utcp-demo/intelligence_service.py

    steps:
      - uses: actions/checkout@v5

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install Poetry
        uses: snok/install-poetry@v1
        with:
          version: ${{ env.POETRY_VERSION }}
          virtualenvs-create: true
          virtualenvs-in-project: true

      - name: Cache dependencies
        uses: actions/cache@v3
        with:
          path: .venv
          key: poetry-utcp-${{ runner.os }}-${{ hashFiles('**/poetry.lock') }}

      - name: Install dependencies
        run: |
          poetry install
          poetry add utcp utcp-http anthropic

      - name: Validate service configuration
        run: |
          echo "Validating ${{ matrix.service.name }}..."
          python -c "
          import sys
          sys.path.insert(0, '.')

          # Import and validate service
          from maestro_core_api import APIConfig
          from maestro_core_api.utcp_extensions import UTCPEnabledAPI

          print('✅ UTCP dependencies validated')
          "

      - name: Test UTCP manual generation
        run: |
          poetry run python -c "
          from maestro_core_api import APIConfig
          from maestro_core_api.utcp_adapter import UTCPManualGenerator
          from fastapi import FastAPI

          app = FastAPI(title='Test Service')

          @app.get('/test')
          async def test():
              return {'status': 'ok'}

          generator = UTCPManualGenerator(app, base_url='http://test:8000')
          manual = generator.generate_manual()

          assert 'manual_version' in manual
          assert 'tools' in manual
          assert 'metadata' in manual

          print('✅ UTCP manual generation test passed')
          print(f'   Generated {len(manual[\"tools\"])} tools')
          "

      - name: Test service startup
        timeout-minutes: 2
        run: |
          echo "Testing ${{ matrix.service.name }} startup..."

          # Start service in background
          poetry run python ${{ matrix.service.path }} &
          SERVICE_PID=$!

          # Wait for service to start
          for i in {1..30}; do
            if curl -s http://localhost:${{ matrix.service.port }}/health > /dev/null 2>&1; then
              echo "✅ Service started successfully"
              break
            fi
            sleep 1
          done

          # Test UTCP endpoints
          echo "Testing UTCP endpoints..."

          # Check UTCP manual
          if curl -f http://localhost:${{ matrix.service.port }}/utcp-manual.json > /dev/null 2>&1; then
            echo "✅ UTCP manual endpoint available"
          else
            echo "❌ UTCP manual endpoint not available"
            kill $SERVICE_PID
            exit 1
          fi

          # Check tools endpoint
          if curl -f http://localhost:${{ matrix.service.port }}/utcp/tools > /dev/null 2>&1; then
            echo "✅ UTCP tools endpoint available"
          else
            echo "❌ UTCP tools endpoint not available"
            kill $SERVICE_PID
            exit 1
          fi

          # Cleanup
          kill $SERVICE_PID
          echo "✅ All UTCP endpoint tests passed"

      - name: Build service metadata
        id: metadata
        run: |
          echo "service_name=${{ matrix.service.name }}" >> $GITHUB_OUTPUT
          echo "service_port=${{ matrix.service.port }}" >> $GITHUB_OUTPUT
          echo "version=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
          echo "timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_OUTPUT

  # Job 2: Build Docker Images
  build-docker:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: build-test
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'

    strategy:
      matrix:
        service:
          - workflow-engine
          - intelligence-service

    steps:
      - uses: actions/checkout@v5

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_REGISTRY }}/${{ github.repository }}/${{ matrix.service }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./examples/utcp-demo/Dockerfile.${{ matrix.service }}
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            SERVICE_NAME=${{ matrix.service }}
            VERSION=${{ steps.meta.outputs.version }}

  # Job 3: Deploy to Kubernetes with Auto-Registration
  deploy-k8s:
    name: Deploy to Kubernetes
    runs-on: ubuntu-latest
    needs: build-docker
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop')

    strategy:
      matrix:
        service:
          - name: workflow-engine
            port: 8001
            replicas: 2
          - name: intelligence-service
            port: 8002
            replicas: 2

    steps:
      - uses: actions/checkout@v5

      - name: Set environment
        id: env
        run: |
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "namespace=maestro-prod" >> $GITHUB_OUTPUT
          else
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "namespace=maestro-staging" >> $GITHUB_OUTPUT
          fi

      - name: Configure kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Set kubectl context
        run: |
          # Configure kubectl context (assumes kubeconfig is in secrets)
          echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > kubeconfig.yaml
          export KUBECONFIG=kubeconfig.yaml
          kubectl config use-context ${{ steps.env.outputs.environment }}

      - name: Create namespace if not exists
        run: |
          kubectl create namespace ${{ steps.env.outputs.namespace }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy service
        run: |
          # Apply Kubernetes manifests
          envsubst < deployment/k8s/${{ matrix.service.name }}-deployment.yaml | kubectl apply -n ${{ steps.env.outputs.namespace }} -f -

          # Wait for rollout
          kubectl rollout status deployment/${{ matrix.service.name }} -n ${{ steps.env.outputs.namespace }} --timeout=5m

      - name: Verify service health
        run: |
          # Get service endpoint
          SERVICE_URL=$(kubectl get svc ${{ matrix.service.name }} -n ${{ steps.env.outputs.namespace }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          SERVICE_PORT=${{ matrix.service.port }}

          echo "Checking service health at http://${SERVICE_URL}:${SERVICE_PORT}/health"

          # Wait for service to be healthy
          for i in {1..30}; do
            if curl -f http://${SERVICE_URL}:${SERVICE_PORT}/health; then
              echo "✅ Service is healthy"
              break
            fi
            sleep 5
          done

      - name: Register service with UTCP registry
        run: |
          # Get service URL
          SERVICE_URL=$(kubectl get svc ${{ matrix.service.name }} -n ${{ steps.env.outputs.namespace }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          SERVICE_PORT=${{ matrix.service.port }}

          echo "Registering service with UTCP registry..."

          # Call UTCP registry registration endpoint
          curl -X POST ${{ env.REGISTRY_URL }}/registry/services \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${{ secrets.UTCP_REGISTRY_TOKEN }}" \
            -d "{
              \"name\": \"${{ matrix.service.name }}\",
              \"base_url\": \"http://${SERVICE_URL}:${SERVICE_PORT}\",
              \"environment\": \"${{ steps.env.outputs.environment }}\",
              \"version\": \"${{ github.sha }}\",
              \"deployed_at\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\",
              \"tags\": [\"utcp\", \"maestro\", \"${{ steps.env.outputs.environment }}\"]
            }"

          echo "✅ Service registered with UTCP registry"

      - name: Verify UTCP endpoints
        run: |
          SERVICE_URL=$(kubectl get svc ${{ matrix.service.name }} -n ${{ steps.env.outputs.namespace }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          SERVICE_PORT=${{ matrix.service.port }}

          echo "Verifying UTCP endpoints..."

          # Check UTCP manual
          MANUAL=$(curl -f http://${SERVICE_URL}:${SERVICE_PORT}/utcp-manual.json)
          echo "✅ UTCP manual available"

          # Extract and display tool count
          TOOL_COUNT=$(echo "$MANUAL" | jq '.tools | length')
          echo "   Service exposes $TOOL_COUNT tools"

          # Verify tools endpoint
          curl -f http://${SERVICE_URL}:${SERVICE_PORT}/utcp/tools
          echo "✅ UTCP tools endpoint available"

  # Job 4: Integration Test with Registry
  integration-test:
    name: Integration Test
    runs-on: ubuntu-latest
    needs: deploy-k8s

    steps:
      - uses: actions/checkout@v5

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install Poetry
        uses: snok/install-poetry@v1
        with:
          version: ${{ env.POETRY_VERSION }}

      - name: Install dependencies
        run: poetry install

      - name: Test service discovery
        run: |
          poetry run python -c "
          import asyncio
          from maestro_core_api.utcp_registry import UTCPServiceRegistry

          async def test_discovery():
              registry = UTCPServiceRegistry()

              # Discover services
              services = await registry.discover_services([
                  'http://workflow-engine:8001',
                  'http://intelligence-service:8002'
              ], fail_on_error=False)

              print(f'✅ Discovered {len(services)} services')

              for service in services:
                  print(f'   • {service.name}: {len(service.manual.get(\"tools\", []))} tools')

              # List all available tools
              tools = registry.list_available_tools()
              print(f'✅ Total tools available: {len(tools)}')

          asyncio.run(test_discovery())
          "

      - name: Test Claude orchestration
        if: env.ANTHROPIC_API_KEY != ''
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          poetry run python -c "
          import asyncio
          from maestro_core_api.claude_orchestrator import ClaudeUTCPOrchestrator

          async def test_orchestration():
              orchestrator = ClaudeUTCPOrchestrator()

              await orchestrator.initialize([
                  'http://workflow-engine:8001',
                  'http://intelligence-service:8002'
              ])

              result = await orchestrator.process_request(
                  'Create a moderate complexity testing workflow'
              )

              print(f'✅ Orchestration test: {\"passed\" if result.success else \"failed\"}')
              print(f'   Tool calls: {len(result.tool_calls)}')
              print(f'   Tokens used: {result.tokens_used.get(\"total\", 0)}')

          asyncio.run(test_orchestration())
          "

  # Job 5: Performance Monitoring
  performance:
    name: Performance Metrics
    runs-on: ubuntu-latest
    needs: integration-test

    steps:
      - uses: actions/checkout@v5

      - name: Run load test
        run: |
          # Install k6 for load testing
          sudo apt-get update
          sudo apt-get install -y k6

          # Run load test
          k6 run examples/utcp-demo/load-test.js

      - name: Measure latency
        run: |
          echo "Measuring UTCP call latency..."

          for i in {1..100}; do
            START=$(date +%s%N)
            curl -s http://workflow-engine:8001/utcp/tools > /dev/null
            END=$(date +%s%N)
            LATENCY=$(( (END - START) / 1000000 ))
            echo "$LATENCY ms"
          done | awk '{sum+=$1; count++} END {print "Average latency:", sum/count, "ms"}'

  # Job 6: Rollback on Failure
  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: [deploy-k8s, integration-test]
    if: failure()

    steps:
      - name: Rollback deployment
        run: |
          echo "⚠️  Deployment failed, rolling back..."

          # Rollback to previous version
          kubectl rollout undo deployment/workflow-engine -n ${{ env.NAMESPACE }}
          kubectl rollout undo deployment/intelligence-service -n ${{ env.NAMESPACE }}

          echo "✅ Rollback completed"

  # Job 7: Notify
  notify:
    name: Notify Team
    runs-on: ubuntu-latest
    needs: [build-test, deploy-k8s, integration-test, performance]
    if: always()

    steps:
      - name: Notify on success
        if: needs.integration-test.result == 'success'
        run: |
          echo "✅ UTCP services deployed successfully!"
          echo "   • Services are registered with UTCP registry"
          echo "   • All health checks passed"
          echo "   • Integration tests passed"
          echo "   • Performance metrics collected"

      - name: Notify on failure
        if: needs.integration-test.result == 'failure' || needs.deploy-k8s.result == 'failure'
        run: |
          echo "❌ UTCP service deployment failed"
          echo "   Check logs for details"
          exit 1