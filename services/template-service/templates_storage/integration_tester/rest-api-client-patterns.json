{
  "metadata": {
    "id": "rest-api-client-v1",
    "name": "REST API Client with Axios Interceptors",
    "category": "integration",
    "language": "typescript",
    "framework": "axios",
    "description": "Production-ready REST API client with interceptors, retry logic, request/response transformation, error handling, and authentication",
    "tags": ["rest-api", "axios", "http-client", "interceptors", "retry-logic", "error-handling"],
    "quality_score": 90.0,
    "security_score": 88.0,
    "performance_score": 89.0,
    "maintainability_score": 91.0,
    "test_coverage": 87.0,
    "usage_count": 0,
    "success_rate": 0.0,
    "status": "approved",
    "created_at": "2025-10-04T20:00:00.000000",
    "updated_at": "2025-10-04T20:00:00.000000",
    "created_by": "template_enhancement_phase1",
    "persona": "integration_tester"
  },
  "content": "import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse, AxiosError } from 'axios';\nimport axiosRetry from 'axios-retry';\n\n// Types\ninterface ApiClientConfig {\n  baseURL: string;\n  timeout?: number;\n  retries?: number;\n  retryDelay?: number;\n  onTokenRefresh?: () => Promise<string>;\n}\n\ninterface ApiError {\n  message: string;\n  statusCode: number;\n  code?: string;\n  details?: any;\n}\n\nclass ApiClient {\n  private client: AxiosInstance;\n  private tokenRefreshPromise: Promise<string> | null = null;\n  \n  constructor(config: ApiClientConfig) {\n    this.client = axios.create({\n      baseURL: config.baseURL,\n      timeout: config.timeout || 10000,\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    });\n    \n    // Configure retry logic\n    axiosRetry(this.client, {\n      retries: config.retries || 3,\n      retryDelay: (retryCount) => {\n        return retryCount * (config.retryDelay || 1000);\n      },\n      retryCondition: (error) => {\n        // Retry on network errors and 5xx server errors\n        return axiosRetry.isNetworkOrIdempotentRequestError(error) ||\n               (error.response?.status >= 500 && error.response?.status < 600);\n      },\n    });\n    \n    this.setupInterceptors(config.onTokenRefresh);\n  }\n  \n  private setupInterceptors(onTokenRefresh?: () => Promise<string>) {\n    // Request Interceptor\n    this.client.interceptors.request.use(\n      (config) => {\n        // Add auth token\n        const token = this.getToken();\n        if (token) {\n          config.headers.Authorization = `Bearer ${token}`;\n        }\n        \n        // Add correlation ID\n        config.headers['X-Correlation-ID'] = this.generateCorrelationId();\n        \n        // Add timestamp\n        config.headers['X-Request-Time'] = new Date().toISOString();\n        \n        // Log request (in development)\n        if (process.env.NODE_ENV === 'development') {\n          console.log('→', config.method?.toUpperCase(), config.url, config.data);\n        }\n        \n        return config;\n      },\n      (error) => {\n        return Promise.reject(error);\n      }\n    );\n    \n    // Response Interceptor\n    this.client.interceptors.response.use(\n      (response) => {\n        // Transform response\n        if (process.env.NODE_ENV === 'development') {\n          console.log('←', response.status, response.config.url, response.data);\n        }\n        \n        return response;\n      },\n      async (error: AxiosError) => {\n        const originalRequest = error.config as AxiosRequestConfig & { _retry?: boolean };\n        \n        // Handle 401 Unauthorized - Token refresh\n        if (error.response?.status === 401 && !originalRequest._retry && onTokenRefresh) {\n          originalRequest._retry = true;\n          \n          try {\n            // Prevent multiple simultaneous refresh requests\n            if (!this.tokenRefreshPromise) {\n              this.tokenRefreshPromise = onTokenRefresh();\n            }\n            \n            const newToken = await this.tokenRefreshPromise;\n            this.tokenRefreshPromise = null;\n            \n            this.setToken(newToken);\n            \n            if (originalRequest.headers) {\n              originalRequest.headers.Authorization = `Bearer ${newToken}`;\n            }\n            \n            return this.client(originalRequest);\n          } catch (refreshError) {\n            this.clearToken();\n            window.location.href = '/login';\n            return Promise.reject(refreshError);\n          }\n        }\n        \n        // Transform error\n        const apiError = this.transformError(error);\n        \n        // Log error\n        console.error('API Error:', apiError);\n        \n        return Promise.reject(apiError);\n      }\n    );\n  }\n  \n  private transformError(error: AxiosError): ApiError {\n    if (error.response) {\n      // Server responded with error status\n      return {\n        message: (error.response.data as any)?.message || error.message,\n        statusCode: error.response.status,\n        code: (error.response.data as any)?.code,\n        details: (error.response.data as any)?.details,\n      };\n    } else if (error.request) {\n      // Request made but no response\n      return {\n        message: 'Network error - no response from server',\n        statusCode: 0,\n        code: 'NETWORK_ERROR',\n      };\n    } else {\n      // Error in request setup\n      return {\n        message: error.message,\n        statusCode: 0,\n        code: 'REQUEST_SETUP_ERROR',\n      };\n    }\n  }\n  \n  private generateCorrelationId(): string {\n    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n  \n  private getToken(): string | null {\n    return localStorage.getItem('auth_token');\n  }\n  \n  private setToken(token: string): void {\n    localStorage.setItem('auth_token', token);\n  }\n  \n  private clearToken(): void {\n    localStorage.removeItem('auth_token');\n  }\n  \n  // HTTP Methods\n  async get<T = any>(url: string, config?: AxiosRequestConfig): Promise<T> {\n    const response = await this.client.get<T>(url, config);\n    return response.data;\n  }\n  \n  async post<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {\n    const response = await this.client.post<T>(url, data, config);\n    return response.data;\n  }\n  \n  async put<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {\n    const response = await this.client.put<T>(url, data, config);\n    return response.data;\n  }\n  \n  async patch<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {\n    const response = await this.client.patch<T>(url, data, config);\n    return response.data;\n  }\n  \n  async delete<T = any>(url: string, config?: AxiosRequestConfig): Promise<T> {\n    const response = await this.client.delete<T>(url, config);\n    return response.data;\n  }\n  \n  // Upload with progress\n  async upload<T = any>(\n    url: string,\n    formData: FormData,\n    onProgress?: (progress: number) => void\n  ): Promise<T> {\n    const response = await this.client.post<T>(url, formData, {\n      headers: { 'Content-Type': 'multipart/form-data' },\n      onUploadProgress: (progressEvent) => {\n        if (onProgress && progressEvent.total) {\n          const progress = Math.round((progressEvent.loaded * 100) / progressEvent.total);\n          onProgress(progress);\n        }\n      },\n    });\n    return response.data;\n  }\n  \n  // Download with progress\n  async download(\n    url: string,\n    filename: string,\n    onProgress?: (progress: number) => void\n  ): Promise<void> {\n    const response = await this.client.get(url, {\n      responseType: 'blob',\n      onDownloadProgress: (progressEvent) => {\n        if (onProgress && progressEvent.total) {\n          const progress = Math.round((progressEvent.loaded * 100) / progressEvent.total);\n          onProgress(progress);\n        }\n      },\n    });\n    \n    const blob = new Blob([response.data]);\n    const link = document.createElement('a');\n    link.href = window.URL.createObjectURL(blob);\n    link.download = filename;\n    link.click();\n    window.URL.revokeObjectURL(link.href);\n  }\n}\n\n// Usage Example\nconst apiClient = new ApiClient({\n  baseURL: 'https://api.example.com',\n  timeout: 15000,\n  retries: 3,\n  retryDelay: 1000,\n  onTokenRefresh: async () => {\n    const refreshToken = localStorage.getItem('refresh_token');\n    const response = await axios.post('https://api.example.com/auth/refresh', {\n      refreshToken,\n    });\n    return response.data.accessToken;\n  },\n});\n\n// API Service Layer\nexport class UserService {\n  static async getUsers(page: number = 1, limit: number = 10) {\n    return apiClient.get(`/users?page=${page}&limit=${limit}`);\n  }\n  \n  static async getUser(id: string) {\n    return apiClient.get(`/users/${id}`);\n  }\n  \n  static async createUser(data: any) {\n    return apiClient.post('/users', data);\n  }\n  \n  static async updateUser(id: string, data: any) {\n    return apiClient.put(`/users/${id}`, data);\n  }\n  \n  static async deleteUser(id: string) {\n    return apiClient.delete(`/users/${id}`);\n  }\n  \n  static async uploadAvatar(file: File, onProgress?: (progress: number) => void) {\n    const formData = new FormData();\n    formData.append('avatar', file);\n    return apiClient.upload('/users/avatar', formData, onProgress);\n  }\n}\n\n// React Hook\nexport function useApiClient() {\n  const [loading, setLoading] = React.useState(false);\n  const [error, setError] = React.useState<ApiError | null>(null);\n  \n  const execute = async <T,>(apiCall: () => Promise<T>): Promise<T | null> => {\n    setLoading(true);\n    setError(null);\n    \n    try {\n      const result = await apiCall();\n      return result;\n    } catch (err) {\n      setError(err as ApiError);\n      return null;\n    } finally {\n      setLoading(false);\n    }\n  };\n  \n  return { execute, loading, error };\n}\n\nexport default apiClient;",
  "variables": {},
  "dependencies": [
    "axios@^1.6.5",
    "axios-retry@^4.0.0"
  ],
  "workflow_context": {
    "typical_use_cases": [
      "REST API integration",
      "HTTP client with retry logic",
      "Token refresh handling",
      "File upload/download",
      "Error handling patterns"
    ],
    "team_composition": ["integration_tester", "frontend_developer", "backend_developer"],
    "estimated_time_minutes": 55,
    "prerequisites": [
      "REST API endpoint",
      "Authentication system",
      "Understanding of HTTP",
      "Error handling strategy"
    ],
    "related_templates": [
      "api-error-handling",
      "authentication-flow",
      "file-upload-download"
    ]
  }
}
