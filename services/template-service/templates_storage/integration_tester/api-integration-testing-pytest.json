{
  "metadata": {
    "id": "api-integration-testing-pytest-v1",
    "name": "REST API Integration Testing with Pytest & Fixtures",
    "category": "testing",
    "language": "python",
    "framework": "pytest",
    "description": "Comprehensive REST API integration testing suite with pytest fixtures, request validation, response schemas, authentication handling, database cleanup, and CI/CD integration",
    "tags": [
      "pytest",
      "integration-testing",
      "api-testing",
      "rest-api",
      "fixtures",
      "test-automation",
      "ci-cd"
    ],
    "quality_score": 91.0,
    "security_score": 87.0,
    "performance_score": 85.0,
    "maintainability_score": 93.0,
    "test_coverage": 90.0,
    "usage_count": 0,
    "success_rate": 0.0,
    "status": "approved",
    "created_at": "2025-10-08T00:00:00.000000",
    "updated_at": "2025-10-08T00:00:00.000000",
    "created_by": "template_gap_analysis_phase",
    "persona": "integration_tester"
  },
  "content": "# conftest.py - Pytest configuration and shared fixtures\nimport pytest\nimport asyncio\nfrom typing import Generator, AsyncGenerator\nimport httpx\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom fastapi.testclient import TestClient\nfrom redis import Redis\nimport os\nfrom datetime import datetime, timedelta\nimport jwt\n\n# Import your app\nfrom app.main import app\nfrom app.database import Base, get_db\nfrom app.config import settings\n\n# Test database URL\nTEST_DATABASE_URL = os.getenv(\n    \"TEST_DATABASE_URL\",\n    \"postgresql://test_user:test_pass@localhost:5432/test_db\"\n)\n\n# Test Redis\nTEST_REDIS_URL = os.getenv(\"TEST_REDIS_URL\", \"redis://localhost:6379/1\")\n\n\n@pytest.fixture(scope=\"session\")\ndef event_loop():\n    \"\"\"Create event loop for async tests.\"\"\"\n    loop = asyncio.get_event_loop_policy().new_event_loop()\n    yield loop\n    loop.close()\n\n\n@pytest.fixture(scope=\"session\")\ndef engine():\n    \"\"\"Create test database engine.\"\"\"\n    engine = create_engine(TEST_DATABASE_URL)\n    Base.metadata.create_all(bind=engine)\n    yield engine\n    Base.metadata.drop_all(bind=engine)\n    engine.dispose()\n\n\n@pytest.fixture(scope=\"function\")\ndef db_session(engine) -> Generator[Session, None, None]:\n    \"\"\"Create a new database session for each test.\"\"\"\n    connection = engine.connect()\n    transaction = connection.begin()\n    session = sessionmaker(bind=connection)()\n    \n    yield session\n    \n    session.close()\n    transaction.rollback()\n    connection.close()\n\n\n@pytest.fixture(scope=\"function\")\ndef client(db_session) -> Generator[TestClient, None, None]:\n    \"\"\"Create test client with database override.\"\"\"\n    def override_get_db():\n        try:\n            yield db_session\n        finally:\n            pass\n    \n    app.dependency_overrides[get_db] = override_get_db\n    \n    with TestClient(app) as test_client:\n        yield test_client\n    \n    app.dependency_overrides.clear()\n\n\n@pytest.fixture(scope=\"function\")\nasync def async_client(db_session) -> AsyncGenerator[httpx.AsyncClient, None]:\n    \"\"\"Create async test client.\"\"\"\n    def override_get_db():\n        try:\n            yield db_session\n        finally:\n            pass\n    \n    app.dependency_overrides[get_db] = override_get_db\n    \n    async with httpx.AsyncClient(\n        app=app,\n        base_url=\"http://test\"\n    ) as ac:\n        yield ac\n    \n    app.dependency_overrides.clear()\n\n\n@pytest.fixture(scope=\"function\")\ndef redis_client():\n    \"\"\"Create Redis client for testing.\"\"\"\n    client = Redis.from_url(TEST_REDIS_URL, decode_responses=True)\n    yield client\n    client.flushdb()\n    client.close()\n\n\n@pytest.fixture\ndef test_user_data():\n    \"\"\"Sample user data for testing.\"\"\"\n    return {\n        \"email\": \"test@example.com\",\n        \"password\": \"SecureP@ssw0rd\",\n        \"name\": \"Test User\",\n        \"role\": \"user\"\n    }\n\n\n@pytest.fixture\ndef test_admin_data():\n    \"\"\"Sample admin user data.\"\"\"\n    return {\n        \"email\": \"admin@example.com\",\n        \"password\": \"AdminP@ssw0rd\",\n        \"name\": \"Admin User\",\n        \"role\": \"admin\"\n    }\n\n\n@pytest.fixture\ndef created_user(client, test_user_data, db_session):\n    \"\"\"Create a test user in the database.\"\"\"\n    from app.models import User\n    from app.auth import get_password_hash\n    \n    user = User(\n        email=test_user_data[\"email\"],\n        hashed_password=get_password_hash(test_user_data[\"password\"]),\n        name=test_user_data[\"name\"],\n        role=test_user_data[\"role\"],\n    )\n    db_session.add(user)\n    db_session.commit()\n    db_session.refresh(user)\n    \n    return user\n\n\n@pytest.fixture\ndef auth_token(created_user):\n    \"\"\"Generate JWT token for authenticated requests.\"\"\"\n    payload = {\n        \"sub\": str(created_user.id),\n        \"email\": created_user.email,\n        \"role\": created_user.role,\n        \"exp\": datetime.utcnow() + timedelta(hours=1)\n    }\n    token = jwt.encode(payload, settings.SECRET_KEY, algorithm=\"HS256\")\n    return token\n\n\n@pytest.fixture\ndef auth_headers(auth_token):\n    \"\"\"Create authorization headers.\"\"\"\n    return {\"Authorization\": f\"Bearer {auth_token}\"}\n\n\n@pytest.fixture\ndef admin_token(db_session, test_admin_data):\n    \"\"\"Generate admin JWT token.\"\"\"\n    from app.models import User\n    from app.auth import get_password_hash\n    \n    admin = User(\n        email=test_admin_data[\"email\"],\n        hashed_password=get_password_hash(test_admin_data[\"password\"]),\n        name=test_admin_data[\"name\"],\n        role=\"admin\",\n    )\n    db_session.add(admin)\n    db_session.commit()\n    db_session.refresh(admin)\n    \n    payload = {\n        \"sub\": str(admin.id),\n        \"email\": admin.email,\n        \"role\": \"admin\",\n        \"exp\": datetime.utcnow() + timedelta(hours=1)\n    }\n    return jwt.encode(payload, settings.SECRET_KEY, algorithm=\"HS256\")\n\n\n@pytest.fixture\ndef admin_headers(admin_token):\n    \"\"\"Create admin authorization headers.\"\"\"\n    return {\"Authorization\": f\"Bearer {admin_token}\"}\n\n\n# tests/test_api_users.py - User API integration tests\nimport pytest\nfrom fastapi import status\n\n\nclass TestUserRegistration:\n    \"\"\"Test user registration endpoints.\"\"\"\n    \n    def test_register_new_user_success(self, client, test_user_data):\n        \"\"\"Test successful user registration.\"\"\"\n        response = client.post(\n            \"/api/v1/auth/register\",\n            json=test_user_data\n        )\n        \n        assert response.status_code == status.HTTP_201_CREATED\n        data = response.json()\n        assert \"id\" in data\n        assert data[\"email\"] == test_user_data[\"email\"]\n        assert data[\"name\"] == test_user_data[\"name\"]\n        assert \"password\" not in data\n        assert \"hashed_password\" not in data\n    \n    def test_register_duplicate_email_fails(self, client, created_user, test_user_data):\n        \"\"\"Test registration with existing email fails.\"\"\"\n        response = client.post(\n            \"/api/v1/auth/register\",\n            json=test_user_data\n        )\n        \n        assert response.status_code == status.HTTP_400_BAD_REQUEST\n        assert \"already registered\" in response.json()[\"detail\"].lower()\n    \n    @pytest.mark.parametrize(\"invalid_email\", [\n        \"notanemail\",\n        \"@example.com\",\n        \"user@\",\n        \"\",\n    ])\n    def test_register_invalid_email_fails(self, client, invalid_email):\n        \"\"\"Test registration with invalid email formats.\"\"\"\n        response = client.post(\n            \"/api/v1/auth/register\",\n            json={\n                \"email\": invalid_email,\n                \"password\": \"SecureP@ssw0rd\",\n                \"name\": \"Test User\"\n            }\n        )\n        \n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n    \n    def test_register_weak_password_fails(self, client):\n        \"\"\"Test registration with weak password.\"\"\"\n        response = client.post(\n            \"/api/v1/auth/register\",\n            json={\n                \"email\": \"test@example.com\",\n                \"password\": \"weak\",\n                \"name\": \"Test User\"\n            }\n        )\n        \n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n\nclass TestUserAuthentication:\n    \"\"\"Test authentication endpoints.\"\"\"\n    \n    def test_login_success(self, client, created_user, test_user_data):\n        \"\"\"Test successful login.\"\"\"\n        response = client.post(\n            \"/api/v1/auth/login\",\n            data={\n                \"username\": test_user_data[\"email\"],\n                \"password\": test_user_data[\"password\"]\n            }\n        )\n        \n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert \"access_token\" in data\n        assert \"refresh_token\" in data\n        assert data[\"token_type\"] == \"bearer\"\n    \n    def test_login_wrong_password_fails(self, client, created_user, test_user_data):\n        \"\"\"Test login with wrong password.\"\"\"\n        response = client.post(\n            \"/api/v1/auth/login\",\n            data={\n                \"username\": test_user_data[\"email\"],\n                \"password\": \"WrongPassword123\"\n            }\n        )\n        \n        assert response.status_code == status.HTTP_401_UNAUTHORIZED\n    \n    def test_login_nonexistent_user_fails(self, client):\n        \"\"\"Test login with non-existent email.\"\"\"\n        response = client.post(\n            \"/api/v1/auth/login\",\n            data={\n                \"username\": \"nonexistent@example.com\",\n                \"password\": \"SomePassword123\"\n            }\n        )\n        \n        assert response.status_code == status.HTTP_401_UNAUTHORIZED\n    \n    def test_get_current_user(self, client, created_user, auth_headers):\n        \"\"\"Test getting current user with valid token.\"\"\"\n        response = client.get(\n            \"/api/v1/users/me\",\n            headers=auth_headers\n        )\n        \n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert data[\"id\"] == str(created_user.id)\n        assert data[\"email\"] == created_user.email\n    \n    def test_get_current_user_no_token_fails(self, client):\n        \"\"\"Test getting current user without token.\"\"\"\n        response = client.get(\"/api/v1/users/me\")\n        \n        assert response.status_code == status.HTTP_401_UNAUTHORIZED\n    \n    def test_get_current_user_invalid_token_fails(self, client):\n        \"\"\"Test with invalid token.\"\"\"\n        response = client.get(\n            \"/api/v1/users/me\",\n            headers={\"Authorization\": \"Bearer invalid_token_here\"}\n        )\n        \n        assert response.status_code == status.HTTP_401_UNAUTHORIZED\n\n\nclass TestUserCRUD:\n    \"\"\"Test user CRUD operations.\"\"\"\n    \n    def test_list_users_as_admin(self, client, created_user, admin_headers):\n        \"\"\"Test listing users as admin.\"\"\"\n        response = client.get(\n            \"/api/v1/users\",\n            headers=admin_headers\n        )\n        \n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert \"items\" in data\n        assert \"total\" in data\n        assert len(data[\"items\"]) >= 1\n    \n    def test_list_users_as_regular_user_fails(self, client, auth_headers):\n        \"\"\"Test that regular users cannot list all users.\"\"\"\n        response = client.get(\n            \"/api/v1/users\",\n            headers=auth_headers\n        )\n        \n        assert response.status_code == status.HTTP_403_FORBIDDEN\n    \n    def test_update_own_profile(self, client, created_user, auth_headers):\n        \"\"\"Test user updating their own profile.\"\"\"\n        response = client.patch(\n            f\"/api/v1/users/{created_user.id}\",\n            headers=auth_headers,\n            json={\"name\": \"Updated Name\"}\n        )\n        \n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert data[\"name\"] == \"Updated Name\"\n    \n    def test_update_other_user_profile_fails(self, client, db_session, auth_headers):\n        \"\"\"Test user cannot update another user's profile.\"\"\"\n        from app.models import User\n        from app.auth import get_password_hash\n        \n        # Create another user\n        other_user = User(\n            email=\"other@example.com\",\n            hashed_password=get_password_hash(\"password\"),\n            name=\"Other User\"\n        )\n        db_session.add(other_user)\n        db_session.commit()\n        \n        response = client.patch(\n            f\"/api/v1/users/{other_user.id}\",\n            headers=auth_headers,\n            json={\"name\": \"Hacked Name\"}\n        )\n        \n        assert response.status_code == status.HTTP_403_FORBIDDEN\n    \n    def test_delete_user_as_admin(self, client, created_user, admin_headers):\n        \"\"\"Test admin can delete users.\"\"\"\n        response = client.delete(\n            f\"/api/v1/users/{created_user.id}\",\n            headers=admin_headers\n        )\n        \n        assert response.status_code == status.HTTP_204_NO_CONTENT\n        \n        # Verify user is deleted\n        get_response = client.get(\n            f\"/api/v1/users/{created_user.id}\",\n            headers=admin_headers\n        )\n        assert get_response.status_code == status.HTTP_404_NOT_FOUND\n\n\n# tests/test_api_posts.py - Posts API integration tests\nclass TestPostsCRUD:\n    \"\"\"Test posts CRUD operations.\"\"\"\n    \n    @pytest.fixture\n    def sample_post_data(self):\n        return {\n            \"title\": \"Test Post\",\n            \"content\": \"This is test content for the post.\",\n            \"published\": True\n        }\n    \n    def test_create_post_authenticated(self, client, auth_headers, sample_post_data):\n        \"\"\"Test creating a post as authenticated user.\"\"\"\n        response = client.post(\n            \"/api/v1/posts\",\n            headers=auth_headers,\n            json=sample_post_data\n        )\n        \n        assert response.status_code == status.HTTP_201_CREATED\n        data = response.json()\n        assert data[\"title\"] == sample_post_data[\"title\"]\n        assert data[\"content\"] == sample_post_data[\"content\"]\n        assert \"id\" in data\n        assert \"created_at\" in data\n    \n    def test_create_post_unauthenticated_fails(self, client, sample_post_data):\n        \"\"\"Test creating post without authentication fails.\"\"\"\n        response = client.post(\n            \"/api/v1/posts\",\n            json=sample_post_data\n        )\n        \n        assert response.status_code == status.HTTP_401_UNAUTHORIZED\n    \n    def test_list_posts_public(self, client, auth_headers, sample_post_data):\n        \"\"\"Test listing public posts.\"\"\"\n        # Create a post first\n        client.post(\n            \"/api/v1/posts\",\n            headers=auth_headers,\n            json=sample_post_data\n        )\n        \n        # List posts (public endpoint)\n        response = client.get(\"/api/v1/posts\")\n        \n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert \"items\" in data\n        assert len(data[\"items\"]) >= 1\n    \n    def test_get_post_by_id(self, client, auth_headers, sample_post_data):\n        \"\"\"Test getting specific post by ID.\"\"\"\n        # Create post\n        create_response = client.post(\n            \"/api/v1/posts\",\n            headers=auth_headers,\n            json=sample_post_data\n        )\n        post_id = create_response.json()[\"id\"]\n        \n        # Get post\n        response = client.get(f\"/api/v1/posts/{post_id}\")\n        \n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert data[\"id\"] == post_id\n        assert data[\"title\"] == sample_post_data[\"title\"]\n    \n    def test_update_own_post(self, client, auth_headers, sample_post_data):\n        \"\"\"Test updating own post.\"\"\"\n        # Create post\n        create_response = client.post(\n            \"/api/v1/posts\",\n            headers=auth_headers,\n            json=sample_post_data\n        )\n        post_id = create_response.json()[\"id\"]\n        \n        # Update post\n        response = client.patch(\n            f\"/api/v1/posts/{post_id}\",\n            headers=auth_headers,\n            json={\"title\": \"Updated Title\"}\n        )\n        \n        assert response.status_code == status.HTTP_200_OK\n        assert response.json()[\"title\"] == \"Updated Title\"\n    \n    def test_delete_own_post(self, client, auth_headers, sample_post_data):\n        \"\"\"Test deleting own post.\"\"\"\n        # Create post\n        create_response = client.post(\n            \"/api/v1/posts\",\n            headers=auth_headers,\n            json=sample_post_data\n        )\n        post_id = create_response.json()[\"id\"]\n        \n        # Delete post\n        response = client.delete(\n            f\"/api/v1/posts/{post_id}\",\n            headers=auth_headers\n        )\n        \n        assert response.status_code == status.HTTP_204_NO_CONTENT\n        \n        # Verify deleted\n        get_response = client.get(f\"/api/v1/posts/{post_id}\")\n        assert get_response.status_code == status.HTTP_404_NOT_FOUND\n\n\n# tests/test_api_pagination.py - Pagination tests\nclass TestPagination:\n    \"\"\"Test API pagination.\"\"\"\n    \n    def test_pagination_parameters(self, client, auth_headers):\n        \"\"\"Test pagination with limit and offset.\"\"\"\n        # Create multiple posts\n        for i in range(15):\n            client.post(\n                \"/api/v1/posts\",\n                headers=auth_headers,\n                json={\n                    \"title\": f\"Post {i}\",\n                    \"content\": f\"Content {i}\",\n                    \"published\": True\n                }\n            )\n        \n        # Test pagination\n        response = client.get(\"/api/v1/posts?limit=10&offset=0\")\n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert len(data[\"items\"]) == 10\n        assert data[\"total\"] >= 15\n        \n        # Test second page\n        response2 = client.get(\"/api/v1/posts?limit=10&offset=10\")\n        data2 = response2.json()\n        assert len(data2[\"items\"]) >= 5\n\n\n# tests/conftest_helpers.py - Test helpers\ndef assert_valid_uuid(value: str):\n    \"\"\"Assert value is valid UUID.\"\"\"\n    import uuid\n    try:\n        uuid.UUID(value)\n    except ValueError:\n        pytest.fail(f\"{value} is not a valid UUID\")\n\n\ndef assert_valid_timestamp(value: str):\n    \"\"\"Assert value is valid ISO timestamp.\"\"\"\n    from datetime import datetime\n    try:\n        datetime.fromisoformat(value.replace('Z', '+00:00'))\n    except ValueError:\n        pytest.fail(f\"{value} is not a valid ISO timestamp\")\n\n\ndef assert_response_schema(response_data: dict, required_fields: list):\n    \"\"\"Assert response contains required fields.\"\"\"\n    for field in required_fields:\n        assert field in response_data, f\"Missing required field: {field}\"\n\n\n# pytest.ini\n\"\"\"\n[pytest]\ntestpaths = tests\npython_files = test_*.py\npython_classes = Test*\npython_functions = test_*\naddopts = \n    -v\n    --strict-markers\n    --cov=app\n    --cov-report=html\n    --cov-report=term-missing\n    --cov-fail-under=80\nmarkers =\n    slow: marks tests as slow (deselect with '-m \"not slow\"')\n    integration: integration tests\n    unit: unit tests\n    api: API tests\n\"\"\"",
  "variables": {
    "TEST_DATABASE_URL": "postgresql://test_user:test_pass@localhost:5432/test_db",
    "TEST_REDIS_URL": "redis://localhost:6379/1",
    "API_BASE_URL": "http://localhost:8000",
    "TEST_TIMEOUT": "30"
  },
  "dependencies": [
    "pytest==7.4.3",
    "pytest-asyncio==0.21.1",
    "pytest-cov==4.1.0",
    "httpx==0.25.2",
    "faker==20.1.0",
    "factory-boy==3.3.0",
    "sqlalchemy==2.0.23",
    "redis==5.0.1"
  ],
  "workflow_context": {
    "typical_use_cases": [
      "REST API integration testing",
      "End-to-end API validation",
      "Authentication flow testing",
      "CRUD operation validation",
      "CI/CD pipeline testing",
      "Database transaction testing"
    ],
    "team_composition": [
      "integration_tester",
      "qa_engineer",
      "backend_developer",
      "devops_engineer"
    ],
    "estimated_time_minutes": 75,
    "prerequisites": [
      "Pytest installed",
      "Test database setup",
      "API application running or TestClient available",
      "Understanding of REST API principles",
      "Redis for cache testing (optional)"
    ],
    "related_templates": [
      "pytest-unit-testing",
      "api-performance-testing",
      "test-data-factories",
      "ci-cd-github-actions"
    ]
  }
}
