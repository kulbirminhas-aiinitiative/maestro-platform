{
  "metadata": {
    "id": "github-actions-cicd-fullstack-v1",
    "name": "GitHub Actions Full Stack CI/CD Pipeline",
    "category": "ci_cd",
    "language": "yaml",
    "framework": "github_actions",
    "description": "Production-ready CI/CD pipeline for full-stack applications with automated testing, building, security scanning, and deployment to Kubernetes",
    "tags": [
      "ci-cd",
      "github-actions",
      "automation",
      "testing",
      "deployment",
      "docker",
      "kubernetes",
      "security-scanning"
    ],
    "quality_score": 92.0,
    "security_score": 95.0,
    "performance_score": 90.0,
    "maintainability_score": 93.0,
    "test_coverage": 95.0,
    "usage_count": 0,
    "success_rate": 0.0,
    "status": "approved",
    "created_at": "2025-10-10T10:00:00.000000",
    "updated_at": "2025-10-10T10:00:00.000000",
    "created_by": "week2_template_creation",
    "persona": "devops_engineer"
  },
  "content": "# .github/workflows/fullstack-cicd.yml\n\nname: Full Stack CI/CD Pipeline\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main, develop]\n  workflow_dispatch:  # Manual trigger\n\nenv:\n  REGISTRY: ghcr.io\n  IMAGE_NAME: ${{ github.repository }}\n  NODE_VERSION: '20'\n  PYTHON_VERSION: '3.11'\n\njobs:\n  # Job 1: Backend Testing\n  backend-test:\n    name: Backend Tests & Quality Checks\n    runs-on: ubuntu-latest\n    \n    services:\n      postgres:\n        image: postgres:15\n        env:\n          POSTGRES_USER: test_user\n          POSTGRES_PASSWORD: test_password\n          POSTGRES_DB: test_db\n        ports:\n          - 5432:5432\n        options: >-\n          --health-cmd pg_isready\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n      \n      redis:\n        image: redis:7-alpine\n        ports:\n          - 6379:6379\n        options: >-\n          --health-cmd \"redis-cli ping\"\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n    \n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n      \n      - name: Set up Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: ${{ env.PYTHON_VERSION }}\n          cache: 'pip'\n      \n      - name: Install dependencies\n        run: |\n          cd backend\n          pip install -r requirements.txt\n          pip install pytest pytest-cov pytest-asyncio\n      \n      - name: Run linting (Ruff)\n        run: |\n          cd backend\n          pip install ruff\n          ruff check .\n      \n      - name: Run type checking (MyPy)\n        run: |\n          cd backend\n          pip install mypy\n          mypy . --ignore-missing-imports\n      \n      - name: Run unit tests with coverage\n        env:\n          DATABASE_URL: postgresql://test_user:test_password@localhost:5432/test_db\n          REDIS_URL: redis://localhost:6379/0\n        run: |\n          cd backend\n          pytest tests/ \\\n            --cov=. \\\n            --cov-report=xml \\\n            --cov-report=html \\\n            --cov-report=term-missing \\\n            --cov-fail-under=90\n      \n      - name: Upload coverage to Codecov\n        uses: codecov/codecov-action@v4\n        with:\n          files: ./backend/coverage.xml\n          flags: backend\n          name: backend-coverage\n      \n      - name: Upload coverage artifacts\n        uses: actions/upload-artifact@v4\n        with:\n          name: backend-coverage\n          path: backend/htmlcov/\n  \n  # Job 2: Frontend Testing\n  frontend-test:\n    name: Frontend Tests & Quality Checks\n    runs-on: ubuntu-latest\n    \n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n      \n      - name: Set up Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: ${{ env.NODE_VERSION }}\n          cache: 'npm'\n          cache-dependency-path: frontend/package-lock.json\n      \n      - name: Install dependencies\n        run: |\n          cd frontend\n          npm ci\n      \n      - name: Run linting (ESLint)\n        run: |\n          cd frontend\n          npm run lint\n      \n      - name: Run type checking (TypeScript)\n        run: |\n          cd frontend\n          npm run type-check\n      \n      - name: Run unit tests (Jest)\n        run: |\n          cd frontend\n          npm run test:coverage\n      \n      - name: Run E2E tests (Playwright)\n        run: |\n          cd frontend\n          npx playwright install --with-deps\n          npm run test:e2e\n      \n      - name: Upload coverage to Codecov\n        uses: codecov/codecov-action@v4\n        with:\n          files: ./frontend/coverage/coverage-final.json\n          flags: frontend\n          name: frontend-coverage\n      \n      - name: Upload Playwright report\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: playwright-report\n          path: frontend/playwright-report/\n  \n  # Job 3: Security Scanning\n  security-scan:\n    name: Security Vulnerability Scanning\n    runs-on: ubuntu-latest\n    \n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n      \n      - name: Run Trivy vulnerability scanner\n        uses: aquasecurity/trivy-action@master\n        with:\n          scan-type: 'fs'\n          scan-ref: '.'\n          format: 'sarif'\n          output: 'trivy-results.sarif'\n      \n      - name: Upload Trivy results to GitHub Security\n        uses: github/codeql-action/upload-sarif@v3\n        with:\n          sarif_file: 'trivy-results.sarif'\n      \n      - name: Run Snyk security scan\n        uses: snyk/actions/node@master\n        continue-on-error: true\n        env:\n          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}\n        with:\n          args: --severity-threshold=high\n      \n      - name: Run OWASP Dependency Check\n        uses: dependency-check/Dependency-Check_Action@main\n        with:\n          project: ${{ github.repository }}\n          path: '.'\n          format: 'HTML'\n      \n      - name: Upload dependency check results\n        uses: actions/upload-artifact@v4\n        with:\n          name: dependency-check-report\n          path: reports/\n  \n  # Job 4: Build Docker Images\n  build:\n    name: Build & Push Docker Images\n    needs: [backend-test, frontend-test, security-scan]\n    runs-on: ubuntu-latest\n    if: github.event_name == 'push'\n    \n    permissions:\n      contents: read\n      packages: write\n    \n    strategy:\n      matrix:\n        service: [backend, frontend]\n    \n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n      \n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v3\n      \n      - name: Log in to Container Registry\n        uses: docker/login-action@v3\n        with:\n          registry: ${{ env.REGISTRY }}\n          username: ${{ github.actor }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n      \n      - name: Extract metadata\n        id: meta\n        uses: docker/metadata-action@v5\n        with:\n          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-${{ matrix.service }}\n          tags: |\n            type=ref,event=branch\n            type=ref,event=pr\n            type=semver,pattern={{version}}\n            type=semver,pattern={{major}}.{{minor}}\n            type=sha,prefix={{branch}}-\n      \n      - name: Build and push Docker image\n        uses: docker/build-push-action@v5\n        with:\n          context: ./${{ matrix.service }}\n          push: true\n          tags: ${{ steps.meta.outputs.tags }}\n          labels: ${{ steps.meta.outputs.labels }}\n          cache-from: type=gha\n          cache-to: type=gha,mode=max\n          build-args: |\n            BUILD_DATE=${{ github.event.head_commit.timestamp }}\n            VCS_REF=${{ github.sha }}\n            VERSION=${{ steps.meta.outputs.version }}\n  \n  # Job 5: Deploy to Development\n  deploy-dev:\n    name: Deploy to Development\n    needs: build\n    runs-on: ubuntu-latest\n    if: github.ref == 'refs/heads/develop'\n    environment:\n      name: development\n      url: https://dev.example.com\n    \n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n      \n      - name: Set up kubectl\n        uses: azure/setup-kubectl@v4\n        with:\n          version: 'latest'\n      \n      - name: Configure kubectl\n        run: |\n          mkdir -p $HOME/.kube\n          echo \"${{ secrets.KUBE_CONFIG_DEV }}\" | base64 -d > $HOME/.kube/config\n      \n      - name: Deploy to Kubernetes\n        run: |\n          kubectl set image deployment/backend \\\n            backend=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-backend:develop \\\n            -n development\n          kubectl set image deployment/frontend \\\n            frontend=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-frontend:develop \\\n            -n development\n      \n      - name: Wait for rollout\n        run: |\n          kubectl rollout status deployment/backend -n development --timeout=5m\n          kubectl rollout status deployment/frontend -n development --timeout=5m\n      \n      - name: Run smoke tests\n        run: |\n          curl -f https://dev.example.com/health || exit 1\n          curl -f https://dev.example.com/api/health || exit 1\n      \n      - name: Notify deployment\n        if: always()\n        uses: 8398a7/action-slack@v3\n        with:\n          status: ${{ job.status }}\n          text: 'Development deployment ${{ job.status }}'\n          webhook_url: ${{ secrets.SLACK_WEBHOOK }}\n  \n  # Job 6: Deploy to Production\n  deploy-prod:\n    name: Deploy to Production\n    needs: build\n    runs-on: ubuntu-latest\n    if: github.ref == 'refs/heads/main'\n    environment:\n      name: production\n      url: https://example.com\n    \n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n      \n      - name: Set up kubectl\n        uses: azure/setup-kubectl@v4\n        with:\n          version: 'latest'\n      \n      - name: Configure kubectl\n        run: |\n          mkdir -p $HOME/.kube\n          echo \"${{ secrets.KUBE_CONFIG_PROD }}\" | base64 -d > $HOME/.kube/config\n      \n      - name: Deploy to Kubernetes (Rolling Update)\n        run: |\n          kubectl set image deployment/backend \\\n            backend=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-backend:main \\\n            -n production\n          kubectl set image deployment/frontend \\\n            frontend=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-frontend:main \\\n            -n production\n      \n      - name: Wait for rollout\n        run: |\n          kubectl rollout status deployment/backend -n production --timeout=10m\n          kubectl rollout status deployment/frontend -n production --timeout=10m\n      \n      - name: Run smoke tests\n        run: |\n          sleep 30  # Allow time for services to fully start\n          curl -f https://example.com/health || exit 1\n          curl -f https://example.com/api/health || exit 1\n      \n      - name: Run post-deployment tests\n        run: |\n          # API health check\n          response=$(curl -s -o /dev/null -w \"%{http_code}\" https://example.com/api/health)\n          if [ $response -ne 200 ]; then\n            echo \"Health check failed with status $response\"\n            kubectl rollout undo deployment/backend -n production\n            kubectl rollout undo deployment/frontend -n production\n            exit 1\n          fi\n      \n      - name: Create GitHub Release\n        if: github.ref == 'refs/heads/main'\n        uses: actions/create-release@v1\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          tag_name: v${{ github.run_number }}\n          release_name: Release v${{ github.run_number }}\n          body: |\n            Automated release from commit ${{ github.sha }}\n            \n            ## Changes\n            ${{ github.event.head_commit.message }}\n          draft: false\n          prerelease: false\n      \n      - name: Notify deployment\n        if: always()\n        uses: 8398a7/action-slack@v3\n        with:\n          status: ${{ job.status }}\n          text: 'Production deployment ${{ job.status }} - v${{ github.run_number }}'\n          webhook_url: ${{ secrets.SLACK_WEBHOOK }}\n\n# Workflow configuration for failure notifications\n  notify-failure:\n    name: Notify on Failure\n    needs: [backend-test, frontend-test, security-scan, build]\n    runs-on: ubuntu-latest\n    if: failure()\n    \n    steps:\n      - name: Send failure notification\n        uses: 8398a7/action-slack@v3\n        with:\n          status: failure\n          text: 'CI/CD Pipeline Failed! Check: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}'\n          webhook_url: ${{ secrets.SLACK_WEBHOOK }}",
  "variables": {
    "REGISTRY": "ghcr.io",
    "NODE_VERSION": "20",
    "PYTHON_VERSION": "3.11",
    "KUBERNETES_NAMESPACE_DEV": "development",
    "KUBERNETES_NAMESPACE_PROD": "production"
  },
  "dependencies": [],
  "workflow_context": {
    "typical_use_cases": [
      "Full-stack application CI/CD automation",
      "Automated testing and quality checks",
      "Security vulnerability scanning",
      "Docker image building and registry push",
      "Kubernetes deployment automation",
      "Multi-environment deployment (dev/prod)"
    ],
    "team_composition": [
      "devops_engineer",
      "backend_developer",
      "frontend_developer"
    ],
    "estimated_time_minutes": 60,
    "prerequisites": [
      "GitHub repository with Actions enabled",
      "Container registry access (GitHub Container Registry)",
      "Kubernetes cluster configured",
      "GitHub Secrets configured (KUBE_CONFIG_DEV, KUBE_CONFIG_PROD, SLACK_WEBHOOK)",
      "Backend in /backend directory",
      "Frontend in /frontend directory"
    ],
    "related_templates": [
      "docker-compose-multi-service",
      "kubernetes-deployment",
      "terraform-aws-infrastructure"
    ]
  }
}
