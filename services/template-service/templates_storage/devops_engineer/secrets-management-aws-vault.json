{
  "metadata": {
    "id": "secrets-management-aws-vault-v1",
    "name": "Secrets Management - AWS Secrets Manager & HashiCorp Vault",
    "category": "security",
    "language": "python",
    "framework": "multi",
    "description": "Production-ready secrets management with AWS Secrets Manager and HashiCorp Vault, including automatic rotation, versioning, and application integration",
    "tags": [
      "secrets",
      "security",
      "aws-secrets-manager",
      "hashicorp-vault",
      "credentials",
      "encryption",
      "rotation"
    ],
    "quality_score": 94.0,
    "security_score": 97.0,
    "performance_score": 90.0,
    "maintainability_score": 92.0,
    "test_coverage": 92.0,
    "usage_count": 0,
    "success_rate": 0.0,
    "status": "approved",
    "created_at": "2025-10-10T15:00:00.000000",
    "updated_at": "2025-10-10T15:00:00.000000",
    "created_by": "week2_template_creation",
    "persona": "devops_engineer"
  },
  "content": "# Secrets Management Implementation\n# Supports both AWS Secrets Manager and HashiCorp Vault\n\nimport boto3\nimport hvac\nimport os\nimport json\nfrom typing import Optional, Dict, Any\nfrom datetime import datetime, timedelta\nfrom functools import lru_cache\nimport logging\nfrom contextlib import contextmanager\n\nlogger = logging.getLogger(__name__)\n\n# ===== AWS Secrets Manager Implementation =====\n\nclass AWSSecretsManager:\n    \"\"\"AWS Secrets Manager client with caching and rotation\"\"\"\n    \n    def __init__(self, region_name: str = \"us-east-1\"):\n        self.client = boto3.client(\n            'secretsmanager',\n            region_name=region_name\n        )\n        self.region = region_name\n    \n    def create_secret(\n        self,\n        name: str,\n        secret_value: Dict[str, Any],\n        description: str = \"\",\n        kms_key_id: Optional[str] = None,\n        tags: Optional[Dict[str, str]] = None\n    ) -> Dict:\n        \"\"\"Create a new secret\"\"\"\n        try:\n            params = {\n                'Name': name,\n                'SecretString': json.dumps(secret_value),\n                'Description': description\n            }\n            \n            if kms_key_id:\n                params['KmsKeyId'] = kms_key_id\n            \n            if tags:\n                params['Tags'] = [\n                    {'Key': k, 'Value': v} for k, v in tags.items()\n                ]\n            \n            response = self.client.create_secret(**params)\n            \n            logger.info(f\"Created secret: {name}\")\n            \n            return {\n                'arn': response['ARN'],\n                'name': response['Name'],\n                'version_id': response['VersionId']\n            }\n        \n        except self.client.exceptions.ResourceExistsException:\n            logger.warning(f\"Secret {name} already exists\")\n            return self.get_secret(name)\n        \n        except Exception as e:\n            logger.error(f\"Error creating secret {name}: {str(e)}\")\n            raise\n    \n    @lru_cache(maxsize=128)\n    def get_secret(self, secret_name: str, version_id: Optional[str] = None) -> Dict:\n        \"\"\"Get secret value (with caching)\"\"\"\n        try:\n            params = {'SecretId': secret_name}\n            \n            if version_id:\n                params['VersionId'] = version_id\n            \n            response = self.client.get_secret_value(**params)\n            \n            # Parse secret string\n            if 'SecretString' in response:\n                secret = json.loads(response['SecretString'])\n            else:\n                # Binary secret\n                secret = response['SecretBinary']\n            \n            logger.info(f\"Retrieved secret: {secret_name}\")\n            \n            return {\n                'value': secret,\n                'version_id': response['VersionId'],\n                'arn': response['ARN'],\n                'created_date': response.get('CreatedDate')\n            }\n        \n        except self.client.exceptions.ResourceNotFoundException:\n            logger.error(f\"Secret {secret_name} not found\")\n            raise ValueError(f\"Secret {secret_name} does not exist\")\n        \n        except Exception as e:\n            logger.error(f\"Error retrieving secret {secret_name}: {str(e)}\")\n            raise\n    \n    def update_secret(\n        self,\n        secret_name: str,\n        secret_value: Dict[str, Any],\n        description: Optional[str] = None\n    ) -> Dict:\n        \"\"\"Update secret value (creates new version)\"\"\"\n        try:\n            params = {\n                'SecretId': secret_name,\n                'SecretString': json.dumps(secret_value)\n            }\n            \n            if description:\n                params['Description'] = description\n            \n            response = self.client.update_secret(**params)\n            \n            # Invalidate cache\n            self.get_secret.cache_clear()\n            \n            logger.info(f\"Updated secret: {secret_name}\")\n            \n            return {\n                'arn': response['ARN'],\n                'name': response['Name'],\n                'version_id': response['VersionId']\n            }\n        \n        except Exception as e:\n            logger.error(f\"Error updating secret {secret_name}: {str(e)}\")\n            raise\n    \n    def rotate_secret(\n        self,\n        secret_name: str,\n        rotation_lambda_arn: str,\n        rotation_rules: Optional[Dict] = None\n    ) -> Dict:\n        \"\"\"Enable automatic secret rotation\"\"\"\n        try:\n            params = {\n                'SecretId': secret_name,\n                'RotationLambdaARN': rotation_lambda_arn,\n                'RotationRules': rotation_rules or {\n                    'AutomaticallyAfterDays': 30\n                }\n            }\n            \n            response = self.client.rotate_secret(**params)\n            \n            logger.info(f\"Enabled rotation for secret: {secret_name}\")\n            \n            return response\n        \n        except Exception as e:\n            logger.error(f\"Error rotating secret {secret_name}: {str(e)}\")\n            raise\n    \n    def delete_secret(\n        self,\n        secret_name: str,\n        recovery_window_days: int = 30,\n        force_delete: bool = False\n    ) -> Dict:\n        \"\"\"Delete secret (with recovery window)\"\"\"\n        try:\n            params = {'SecretId': secret_name}\n            \n            if force_delete:\n                params['ForceDeleteWithoutRecovery'] = True\n            else:\n                params['RecoveryWindowInDays'] = recovery_window_days\n            \n            response = self.client.delete_secret(**params)\n            \n            # Invalidate cache\n            self.get_secret.cache_clear()\n            \n            logger.info(f\"Deleted secret: {secret_name} (recovery window: {recovery_window_days} days)\")\n            \n            return response\n        \n        except Exception as e:\n            logger.error(f\"Error deleting secret {secret_name}: {str(e)}\")\n            raise\n    \n    def list_secrets(self, filters: Optional[list] = None) -> list:\n        \"\"\"List all secrets\"\"\"\n        try:\n            params = {}\n            if filters:\n                params['Filters'] = filters\n            \n            response = self.client.list_secrets(**params)\n            \n            return response.get('SecretList', [])\n        \n        except Exception as e:\n            logger.error(f\"Error listing secrets: {str(e)}\")\n            raise\n\n# ===== HashiCorp Vault Implementation =====\n\nclass VaultSecretsManager:\n    \"\"\"HashiCorp Vault client for secrets management\"\"\"\n    \n    def __init__(\n        self,\n        vault_url: str = \"http://localhost:8200\",\n        token: Optional[str] = None,\n        namespace: Optional[str] = None\n    ):\n        self.client = hvac.Client(\n            url=vault_url,\n            token=token or os.environ.get('VAULT_TOKEN'),\n            namespace=namespace\n        )\n        \n        if not self.client.is_authenticated():\n            raise ValueError(\"Vault authentication failed\")\n        \n        logger.info(f\"Connected to Vault at {vault_url}\")\n    \n    def create_secret(\n        self,\n        path: str,\n        secret_data: Dict[str, Any],\n        mount_point: str = \"secret\"\n    ) -> Dict:\n        \"\"\"Create/update a secret in KV v2 engine\"\"\"\n        try:\n            response = self.client.secrets.kv.v2.create_or_update_secret(\n                path=path,\n                secret=secret_data,\n                mount_point=mount_point\n            )\n            \n            logger.info(f\"Created secret at: {mount_point}/{path}\")\n            \n            return {\n                'path': path,\n                'version': response['data']['version'],\n                'created_time': response['data']['created_time']\n            }\n        \n        except Exception as e:\n            logger.error(f\"Error creating secret {path}: {str(e)}\")\n            raise\n    \n    @lru_cache(maxsize=128)\n    def get_secret(\n        self,\n        path: str,\n        version: Optional[int] = None,\n        mount_point: str = \"secret\"\n    ) -> Dict:\n        \"\"\"Get secret from KV v2 engine (with caching)\"\"\"\n        try:\n            response = self.client.secrets.kv.v2.read_secret_version(\n                path=path,\n                version=version,\n                mount_point=mount_point\n            )\n            \n            logger.info(f\"Retrieved secret from: {mount_point}/{path}\")\n            \n            return {\n                'data': response['data']['data'],\n                'metadata': response['data']['metadata'],\n                'version': response['data']['metadata']['version']\n            }\n        \n        except Exception as e:\n            logger.error(f\"Error retrieving secret {path}: {str(e)}\")\n            raise\n    \n    def delete_secret(\n        self,\n        path: str,\n        versions: Optional[list] = None,\n        mount_point: str = \"secret\"\n    ):\n        \"\"\"Delete secret versions\"\"\"\n        try:\n            if versions:\n                # Delete specific versions\n                self.client.secrets.kv.v2.delete_secret_versions(\n                    path=path,\n                    versions=versions,\n                    mount_point=mount_point\n                )\n            else:\n                # Delete latest version\n                self.client.secrets.kv.v2.delete_latest_version_of_secret(\n                    path=path,\n                    mount_point=mount_point\n                )\n            \n            # Invalidate cache\n            self.get_secret.cache_clear()\n            \n            logger.info(f\"Deleted secret: {mount_point}/{path}\")\n        \n        except Exception as e:\n            logger.error(f\"Error deleting secret {path}: {str(e)}\")\n            raise\n    \n    def list_secrets(self, path: str = \"\", mount_point: str = \"secret\") -> list:\n        \"\"\"List secrets at path\"\"\"\n        try:\n            response = self.client.secrets.kv.v2.list_secrets(\n                path=path,\n                mount_point=mount_point\n            )\n            \n            return response['data']['keys']\n        \n        except Exception as e:\n            logger.error(f\"Error listing secrets at {path}: {str(e)}\")\n            raise\n\n# ===== Unified Secrets Interface =====\n\nclass SecretsManager:\n    \"\"\"Unified interface for both AWS and Vault\"\"\"\n    \n    def __init__(self, backend: str = \"aws\", **kwargs):\n        \"\"\"\n        Initialize secrets manager\n        \n        Args:\n            backend: \"aws\" or \"vault\"\n            **kwargs: Backend-specific configuration\n        \"\"\"\n        if backend == \"aws\":\n            self.backend = AWSSecretsManager(\n                region_name=kwargs.get('region', 'us-east-1')\n            )\n        elif backend == \"vault\":\n            self.backend = VaultSecretsManager(\n                vault_url=kwargs.get('vault_url', 'http://localhost:8200'),\n                token=kwargs.get('token'),\n                namespace=kwargs.get('namespace')\n            )\n        else:\n            raise ValueError(f\"Unsupported backend: {backend}\")\n        \n        self.backend_type = backend\n    \n    def get(self, name: str, **kwargs) -> Dict:\n        \"\"\"Get secret value\"\"\"\n        if self.backend_type == \"aws\":\n            result = self.backend.get_secret(name)\n            return result['value']\n        else:  # vault\n            result = self.backend.get_secret(name, **kwargs)\n            return result['data']\n    \n    def set(self, name: str, value: Dict[str, Any], **kwargs):\n        \"\"\"Set/update secret value\"\"\"\n        if self.backend_type == \"aws\":\n            try:\n                return self.backend.update_secret(name, value)\n            except ValueError:\n                # Secret doesn't exist, create it\n                return self.backend.create_secret(name, value, **kwargs)\n        else:  # vault\n            return self.backend.create_secret(name, value, **kwargs)\n    \n    def delete(self, name: str, **kwargs):\n        \"\"\"Delete secret\"\"\"\n        return self.backend.delete_secret(name, **kwargs)\n\n# ===== Application Integration =====\n\nclass Config:\n    \"\"\"Application configuration with secrets\"\"\"\n    \n    def __init__(self, secrets_backend: str = \"aws\"):\n        self.secrets = SecretsManager(backend=secrets_backend)\n    \n    @property\n    def database_url(self) -> str:\n        \"\"\"Get database connection string from secrets\"\"\"\n        db_secrets = self.secrets.get('database/credentials')\n        \n        return (\n            f\"postgresql://{db_secrets['username']}:{db_secrets['password']}\"\n            f\"@{db_secrets['host']}:{db_secrets['port']}/{db_secrets['database']}\"\n        )\n    \n    @property\n    def redis_url(self) -> str:\n        \"\"\"Get Redis connection string from secrets\"\"\"\n        redis_secrets = self.secrets.get('redis/credentials')\n        \n        if redis_secrets.get('password'):\n            return f\"redis://:{redis_secrets['password']}@{redis_secrets['host']}:{redis_secrets['port']}/0\"\n        return f\"redis://{redis_secrets['host']}:{redis_secrets['port']}/0\"\n    \n    @property\n    def api_keys(self) -> Dict[str, str]:\n        \"\"\"Get third-party API keys\"\"\"\n        return self.secrets.get('api/keys')\n    \n    @property\n    def jwt_secret(self) -> str:\n        \"\"\"Get JWT signing secret\"\"\"\n        auth_secrets = self.secrets.get('auth/jwt')\n        return auth_secrets['secret_key']\n\n# ===== Context Manager for Temporary Credentials =====\n\n@contextmanager\ndef temporary_credentials(secrets_manager: SecretsManager, service: str):\n    \"\"\"Context manager for temporary credentials\"\"\"\n    # Generate temporary credentials\n    temp_creds = {\n        'username': f\"temp_{service}_{datetime.utcnow().timestamp()}\",\n        'password': os.urandom(32).hex(),\n        'expires_at': (datetime.utcnow() + timedelta(hours=1)).isoformat()\n    }\n    \n    secret_name = f\"temp/{service}/credentials\"\n    \n    try:\n        # Store temporary credentials\n        secrets_manager.set(secret_name, temp_creds)\n        logger.info(f\"Created temporary credentials for {service}\")\n        \n        yield temp_creds\n    \n    finally:\n        # Clean up\n        try:\n            secrets_manager.delete(secret_name)\n            logger.info(f\"Deleted temporary credentials for {service}\")\n        except Exception as e:\n            logger.error(f\"Error deleting temporary credentials: {str(e)}\")\n\n# ===== Usage Examples =====\n\nif __name__ == \"__main__\":\n    # Example 1: AWS Secrets Manager\n    print(\"\\n=== AWS Secrets Manager ===\")\n    aws_secrets = SecretsManager(backend=\"aws\", region=\"us-east-1\")\n    \n    # Create database credentials\n    aws_secrets.set(\n        \"production/database/credentials\",\n        {\n            \"username\": \"app_user\",\n            \"password\": \"secure_password_123\",\n            \"host\": \"db.example.com\",\n            \"port\": \"5432\",\n            \"database\": \"app_db\"\n        },\n        description=\"Production database credentials\"\n    )\n    \n    # Retrieve credentials\n    db_creds = aws_secrets.get(\"production/database/credentials\")\n    print(f\"Database user: {db_creds['username']}\")\n    \n    # Example 2: HashiCorp Vault\n    print(\"\\n=== HashiCorp Vault ===\")\n    vault_secrets = SecretsManager(\n        backend=\"vault\",\n        vault_url=\"http://localhost:8200\",\n        token=os.environ.get('VAULT_TOKEN')\n    )\n    \n    # Store API keys\n    vault_secrets.set(\n        \"api/keys\",\n        {\n            \"stripe\": \"sk_test_123\",\n            \"sendgrid\": \"SG.123\",\n            \"aws\": \"AKIA123\"\n        },\n        mount_point=\"secret\"\n    )\n    \n    # Retrieve API keys\n    api_keys = vault_secrets.get(\"api/keys\")\n    print(f\"Stripe key: {api_keys['stripe'][:10]}...\")\n    \n    # Example 3: Application Configuration\n    print(\"\\n=== Application Config ===\")\n    config = Config(secrets_backend=\"aws\")\n    print(f\"Database URL: {config.database_url[:30]}...\")\n    \n    # Example 4: Temporary Credentials\n    print(\"\\n=== Temporary Credentials ===\")\n    with temporary_credentials(aws_secrets, \"backup_service\") as temp_creds:\n        print(f\"Temp user: {temp_creds['username']}\")\n        print(f\"Expires: {temp_creds['expires_at']}\")\n        # Use credentials...\n    # Credentials automatically deleted after context",
  "variables": {
    "AWS_REGION": "us-east-1",
    "VAULT_ADDR": "http://localhost:8200",
    "VAULT_TOKEN": "your-vault-token",
    "SECRETS_BACKEND": "aws"
  },
  "dependencies": [
    "boto3==1.34.34",
    "hvac==2.1.0"
  ],
  "workflow_context": {
    "typical_use_cases": [
      "Database credential management",
      "API key storage and rotation",
      "JWT secret management",
      "Third-party service credentials",
      "Temporary credential generation",
      "Multi-environment secret management (dev/staging/prod)",
      "Compliance requirements (SOC2, HIPAA, PCI-DSS)"
    ],
    "team_composition": [
      "devops_engineer",
      "security_specialist",
      "backend_developer"
    ],
    "estimated_time_minutes": 90,
    "prerequisites": [
      "AWS account with Secrets Manager access (for AWS backend)",
      "HashiCorp Vault server running (for Vault backend)",
      "IAM permissions configured",
      "KMS key for encryption (AWS)",
      "Vault token with appropriate policies (Vault)",
      "Understanding of secrets lifecycle"
    ],
    "related_templates": [
      "jwt-authentication-refresh-tokens",
      "terraform-aws-infrastructure",
      "docker-compose-multi-service"
    ]
  }
}
