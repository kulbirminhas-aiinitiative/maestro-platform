{
  "metadata": {
    "id": "websocket-real-time-server-v1",
    "name": "WebSocket Real-Time Server with Broadcasting",
    "category": "real_time",
    "language": "python",
    "framework": "fastapi",
    "description": "Production-ready WebSocket server with connection management, broadcasting, room-based messaging, and Redis pub/sub for horizontal scaling. Perfect for real-time analytics, telemetry, chat, and live updates.",
    "tags": [
      "websocket",
      "real-time",
      "broadcasting",
      "fastapi",
      "redis",
      "pub-sub",
      "connection-management",
      "scalable",
      "telemetry",
      "analytics"
    ],
    "quality_score": 90.0,
    "security_score": 88.0,
    "performance_score": 92.0,
    "maintainability_score": 89.0,
    "test_coverage": 85.0,
    "usage_count": 0,
    "success_rate": 0.0,
    "status": "approved",
    "created_at": "2025-10-09T03:30:00.000000",
    "updated_at": "2025-10-09T03:30:00.000000",
    "created_by": "gap_analysis_tg003",
    "persona": "backend_developer"
  },
  "content": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect, Depends, HTTPException, status\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom typing import Dict, Set, Optional, Any, List\nimport json\nimport asyncio\nimport logging\nfrom datetime import datetime\nfrom collections import defaultdict\nimport redis.asyncio as redis\nfrom pydantic import BaseModel, Field\nimport uuid\n\nlogger = logging.getLogger(__name__)\n\n# Configuration\nREDIS_URL = \"redis://localhost:6379\"\nREDIS_CHANNEL = \"websocket:broadcast\"\n\n# Pydantic Models\nclass MessagePayload(BaseModel):\n    \"\"\"WebSocket message payload\"\"\"\n    type: str = Field(..., description=\"Message type (data, command, event)\")\n    room: Optional[str] = Field(None, description=\"Target room for message\")\n    data: Any = Field(..., description=\"Message data\")\n    timestamp: datetime = Field(default_factory=datetime.utcnow)\n    sender_id: Optional[str] = None\n\nclass ConnectionInfo(BaseModel):\n    \"\"\"Connection metadata\"\"\"\n    connection_id: str\n    connected_at: datetime\n    user_id: Optional[str] = None\n    rooms: Set[str] = Field(default_factory=set)\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n\n# Connection Manager with Room Support\nclass ConnectionManager:\n    \"\"\"\n    Manages WebSocket connections with room-based broadcasting.\n    \n    Features:\n    - Connection lifecycle management\n    - Room-based message routing\n    - Redis pub/sub for horizontal scaling\n    - Connection metadata tracking\n    - Heartbeat/ping-pong for connection health\n    \"\"\"\n\n    def __init__(self):\n        # Active connections by connection_id\n        self.active_connections: Dict[str, WebSocket] = {}\n        \n        # Connection metadata\n        self.connections: Dict[str, ConnectionInfo] = {}\n        \n        # Room memberships (room_name -> set of connection_ids)\n        self.rooms: Dict[str, Set[str]] = defaultdict(set)\n        \n        # Redis for pub/sub (horizontal scaling)\n        self.redis_client: Optional[redis.Redis] = None\n        self.pubsub_task: Optional[asyncio.Task] = None\n\n    async def initialize_redis(self):\n        \"\"\"Initialize Redis connection for pub/sub\"\"\"\n        try:\n            self.redis_client = await redis.from_url(\n                REDIS_URL,\n                encoding=\"utf-8\",\n                decode_responses=True\n            )\n            await self.redis_client.ping()\n            logger.info(\"Redis connection established\")\n            \n            # Start pub/sub listener\n            self.pubsub_task = asyncio.create_task(self._redis_listener())\n        except Exception as e:\n            logger.error(f\"Redis initialization failed: {e}\")\n            self.redis_client = None\n\n    async def _redis_listener(self):\n        \"\"\"Listen for Redis pub/sub messages for broadcasting across instances\"\"\"\n        if not self.redis_client:\n            return\n\n        pubsub = self.redis_client.pubsub()\n        await pubsub.subscribe(REDIS_CHANNEL)\n        \n        logger.info(f\"Listening on Redis channel: {REDIS_CHANNEL}\")\n        \n        try:\n            async for message in pubsub.listen():\n                if message[\"type\"] == \"message\":\n                    try:\n                        data = json.loads(message[\"data\"])\n                        await self._broadcast_local(\n                            data[\"message\"],\n                            room=data.get(\"room\"),\n                            exclude_id=data.get(\"exclude_id\")\n                        )\n                    except Exception as e:\n                        logger.error(f\"Error processing Redis message: {e}\")\n        except Exception as e:\n            logger.error(f\"Redis listener error: {e}\")\n\n    async def connect(self, websocket: WebSocket, connection_id: str, user_id: Optional[str] = None) -> str:\n        \"\"\"Accept WebSocket connection and register it\"\"\"\n        await websocket.accept()\n        \n        self.active_connections[connection_id] = websocket\n        self.connections[connection_id] = ConnectionInfo(\n            connection_id=connection_id,\n            connected_at=datetime.utcnow(),\n            user_id=user_id\n        )\n        \n        logger.info(f\"Connection {connection_id} established (user: {user_id})\")\n        return connection_id\n\n    def disconnect(self, connection_id: str):\n        \"\"\"Remove connection and clean up rooms\"\"\"\n        if connection_id in self.active_connections:\n            del self.active_connections[connection_id]\n        \n        # Remove from all rooms\n        if connection_id in self.connections:\n            for room in self.connections[connection_id].rooms:\n                self.rooms[room].discard(connection_id)\n            del self.connections[connection_id]\n        \n        logger.info(f\"Connection {connection_id} disconnected\")\n\n    async def join_room(self, connection_id: str, room: str):\n        \"\"\"Add connection to a room\"\"\"\n        if connection_id not in self.connections:\n            raise ValueError(f\"Connection {connection_id} not found\")\n        \n        self.rooms[room].add(connection_id)\n        self.connections[connection_id].rooms.add(room)\n        logger.info(f\"Connection {connection_id} joined room: {room}\")\n\n    async def leave_room(self, connection_id: str, room: str):\n        \"\"\"Remove connection from a room\"\"\"\n        self.rooms[room].discard(connection_id)\n        if connection_id in self.connections:\n            self.connections[connection_id].rooms.discard(room)\n        logger.info(f\"Connection {connection_id} left room: {room}\")\n\n    async def send_personal(self, message: Dict[str, Any], connection_id: str):\n        \"\"\"Send message to specific connection\"\"\"\n        if connection_id in self.active_connections:\n            try:\n                await self.active_connections[connection_id].send_json(message)\n            except Exception as e:\n                logger.error(f\"Error sending to {connection_id}: {e}\")\n                self.disconnect(connection_id)\n\n    async def _broadcast_local(self, message: Dict[str, Any], room: Optional[str] = None, exclude_id: Optional[str] = None):\n        \"\"\"Broadcast to local connections only (called by Redis listener)\"\"\"\n        target_ids = self._get_target_connections(room, exclude_id)\n        \n        # Send to all targets\n        disconnected = []\n        for conn_id in target_ids:\n            try:\n                await self.active_connections[conn_id].send_json(message)\n            except Exception as e:\n                logger.error(f\"Error broadcasting to {conn_id}: {e}\")\n                disconnected.append(conn_id)\n        \n        # Clean up disconnected\n        for conn_id in disconnected:\n            self.disconnect(conn_id)\n\n    async def broadcast(self, message: Dict[str, Any], room: Optional[str] = None, exclude_id: Optional[str] = None):\n        \"\"\"Broadcast message to all connections (or room) via Redis pub/sub\"\"\"\n        # Publish to Redis for cross-instance broadcasting\n        if self.redis_client:\n            try:\n                await self.redis_client.publish(\n                    REDIS_CHANNEL,\n                    json.dumps({\n                        \"message\": message,\n                        \"room\": room,\n                        \"exclude_id\": exclude_id\n                    })\n                )\n            except Exception as e:\n                logger.error(f\"Redis publish error: {e}\")\n                # Fallback to local broadcast\n                await self._broadcast_local(message, room, exclude_id)\n        else:\n            # No Redis, broadcast locally only\n            await self._broadcast_local(message, room, exclude_id)\n\n    def _get_target_connections(self, room: Optional[str] = None, exclude_id: Optional[str] = None) -> Set[str]:\n        \"\"\"Get target connection IDs for broadcasting\"\"\"\n        if room:\n            # Room-specific broadcast\n            target_ids = self.rooms.get(room, set()).copy()\n        else:\n            # Broadcast to all\n            target_ids = set(self.active_connections.keys())\n        \n        # Exclude sender if specified\n        if exclude_id:\n            target_ids.discard(exclude_id)\n        \n        return target_ids\n\n    def get_connection_count(self, room: Optional[str] = None) -> int:\n        \"\"\"Get active connection count\"\"\"\n        if room:\n            return len(self.rooms.get(room, set()))\n        return len(self.active_connections)\n\n    def get_rooms(self) -> List[str]:\n        \"\"\"Get list of active rooms\"\"\"\n        return [room for room, members in self.rooms.items() if members]\n\n    async def close(self):\n        \"\"\"Cleanup resources\"\"\"\n        if self.pubsub_task:\n            self.pubsub_task.cancel()\n        if self.redis_client:\n            await self.redis_client.close()\n\n# FastAPI Application\napp = FastAPI(\n    title=\"WebSocket Real-Time Server\",\n    description=\"Production WebSocket server with broadcasting and room support\",\n    version=\"1.0.0\"\n)\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n# Global connection manager\nmanager = ConnectionManager()\n\n@app.on_event(\"startup\")\nasync def startup_event():\n    \"\"\"Initialize on startup\"\"\"\n    await manager.initialize_redis()\n    logger.info(\"WebSocket server started\")\n\n@app.on_event(\"shutdown\")\nasync def shutdown_event():\n    \"\"\"Cleanup on shutdown\"\"\"\n    await manager.close()\n    logger.info(\"WebSocket server shutdown\")\n\n@app.get(\"/\")\nasync def root():\n    \"\"\"Health check endpoint\"\"\"\n    return {\n        \"service\": \"WebSocket Server\",\n        \"status\": \"running\",\n        \"connections\": manager.get_connection_count(),\n        \"rooms\": manager.get_rooms()\n    }\n\n@app.get(\"/stats\")\nasync def get_stats():\n    \"\"\"Get server statistics\"\"\"\n    return {\n        \"total_connections\": manager.get_connection_count(),\n        \"rooms\": {\n            room: manager.get_connection_count(room)\n            for room in manager.get_rooms()\n        },\n        \"redis_connected\": manager.redis_client is not None\n    }\n\n@app.websocket(\"/ws/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str, user_id: Optional[str] = None):\n    \"\"\"\n    WebSocket endpoint with connection management.\n    \n    Usage:\n        ws://localhost:8000/ws/{client_id}?user_id={user_id}\n    \n    Message Format:\n        {\n            \"type\": \"data|command|event\",\n            \"room\": \"optional_room_name\",\n            \"data\": { ... }\n        }\n    \n    Commands:\n        - join_room: Join a room\n        - leave_room: Leave a room\n        - ping: Heartbeat check\n    \"\"\"\n    connection_id = f\"{client_id}_{uuid.uuid4().hex[:8]}\"\n    await manager.connect(websocket, connection_id, user_id)\n    \n    try:\n        # Send welcome message\n        await manager.send_personal({\n            \"type\": \"system\",\n            \"data\": {\n                \"message\": \"Connected successfully\",\n                \"connection_id\": connection_id,\n                \"timestamp\": datetime.utcnow().isoformat()\n            }\n        }, connection_id)\n        \n        # Message loop\n        while True:\n            data = await websocket.receive_text()\n            \n            try:\n                message = json.loads(data)\n                msg_type = message.get(\"type\", \"data\")\n                \n                # Handle commands\n                if msg_type == \"command\":\n                    command = message.get(\"command\")\n                    \n                    if command == \"join_room\":\n                        room = message.get(\"room\")\n                        if room:\n                            await manager.join_room(connection_id, room)\n                            await manager.send_personal({\n                                \"type\": \"system\",\n                                \"data\": {\"message\": f\"Joined room: {room}\"}\n                            }, connection_id)\n                    \n                    elif command == \"leave_room\":\n                        room = message.get(\"room\")\n                        if room:\n                            await manager.leave_room(connection_id, room)\n                            await manager.send_personal({\n                                \"type\": \"system\",\n                                \"data\": {\"message\": f\"Left room: {room}\"}\n                            }, connection_id)\n                    \n                    elif command == \"ping\":\n                        await manager.send_personal({\n                            \"type\": \"pong\",\n                            \"data\": {\"timestamp\": datetime.utcnow().isoformat()}\n                        }, connection_id)\n                \n                # Handle data messages (broadcast)\n                else:\n                    room = message.get(\"room\")\n                    payload = {\n                        \"type\": msg_type,\n                        \"sender_id\": connection_id,\n                        \"data\": message.get(\"data\", message),\n                        \"timestamp\": datetime.utcnow().isoformat()\n                    }\n                    \n                    # Broadcast to room or all\n                    await manager.broadcast(\n                        payload,\n                        room=room,\n                        exclude_id=connection_id  # Don't echo back to sender\n                    )\n            \n            except json.JSONDecodeError:\n                await manager.send_personal({\n                    \"type\": \"error\",\n                    \"data\": {\"message\": \"Invalid JSON\"}\n                }, connection_id)\n            except Exception as e:\n                logger.error(f\"Message handling error: {e}\")\n                await manager.send_personal({\n                    \"type\": \"error\",\n                    \"data\": {\"message\": str(e)}\n                }, connection_id)\n    \n    except WebSocketDisconnect:\n        manager.disconnect(connection_id)\n        logger.info(f\"Client {connection_id} disconnected\")\n    except Exception as e:\n        logger.error(f\"WebSocket error for {connection_id}: {e}\")\n        manager.disconnect(connection_id)\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(\n        \"main:app\",\n        host=\"0.0.0.0\",\n        port=8000,\n        log_level=\"info\",\n        reload=True\n    )",
  "variables": {
    "REDIS_URL": "redis://localhost:6379",
    "REDIS_CHANNEL": "websocket:broadcast",
    "SERVER_HOST": "0.0.0.0",
    "SERVER_PORT": "8000",
    "CORS_ORIGINS": "[\"*\"]"
  },
  "dependencies": [
    "fastapi==0.109.0",
    "uvicorn[standard]==0.27.0",
    "redis[hiredis]==5.0.1",
    "pydantic==2.5.3",
    "python-multipart==0.0.6"
  ],
  "workflow_context": {
    "typical_use_cases": [
      "Real-time analytics dashboards with live data streaming",
      "IoT telemetry processing and device monitoring",
      "Chat applications with room-based messaging",
      "Live notifications and updates",
      "Collaborative editing and real-time sync",
      "Stock/crypto price tickers",
      "Live sports scores and updates",
      "Server monitoring dashboards"
    ],
    "team_composition": [
      "backend_developer",
      "devops_engineer",
      "frontend_developer"
    ],
    "estimated_time_minutes": 30,
    "prerequisites": [
      "Redis server running (for horizontal scaling)",
      "Basic understanding of WebSocket protocol",
      "Familiarity with FastAPI and async Python"
    ],
    "related_templates": [
      "fastapi-async-crud-complete",
      "redis-caching-pattern",
      "real-time-analytics-dashboard",
      "iot-telemetry-processing"
    ],
    "deployment_notes": [
      "Run Redis: docker run -d -p 6379:6379 redis:latest",
      "For production: Use Redis Cluster for HA",
      "Enable sticky sessions for load balancers",
      "Monitor connection counts and memory usage",
      "Set appropriate timeout values for idle connections"
    ],
    "scaling_notes": [
      "Horizontal scaling via Redis pub/sub",
      "Each server instance handles its own connections",
      "Messages broadcast across all instances via Redis",
      "Use Redis Cluster for high availability",
      "Monitor Redis pub/sub latency"
    ]
  }
}
