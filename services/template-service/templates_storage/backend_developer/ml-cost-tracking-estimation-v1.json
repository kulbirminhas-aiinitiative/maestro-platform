{
  "metadata": {
    "id": "ml-cost-tracking-estimation-v1",
    "name": "ML Cost Tracking & Estimation System (Training + Inference)",
    "category": "ml-operations",
    "language": "python",
    "framework": "fastapi",
    "description": "Production-grade ML cost tracking system with training/inference cost calculation, resource usage monitoring, pricing models for AWS/Azure/GCP, cost forecasting, and efficiency metrics. Extracted from Conductor ML Platform.",
    "tags": [
      "ml-ops",
      "cost-tracking",
      "ml-training",
      "inference",
      "gpu-cost",
      "pricing",
      "resource-management",
      "cost-optimization",
      "forecasting"
    ],
    "quality_score": 94.0,
    "security_score": 88.0,
    "performance_score": 91.0,
    "maintainability_score": 93.0,
    "test_coverage": 88.0,
    "usage_count": 0,
    "success_rate": 0.0,
    "status": "approved",
    "created_at": "2025-10-13T00:00:00.000000",
    "updated_at": "2025-10-13T00:00:00.000000",
    "created_by": "template_extraction_ultrathink",
    "persona": "backend_developer"
  },
  "content": "# ML Cost Tracking & Estimation System\n# Production-ready pattern from Conductor ML Platform\n\nfrom typing import List, Optional, Dict, Literal\nfrom datetime import datetime, timedelta\nfrom decimal import Decimal\nfrom pydantic import BaseModel, Field\nfrom enum import Enum\n\n\n# ==================== Data Models ====================\nclass ResourceType(str, Enum):\n    \"\"\"GPU and compute resource types\"\"\"\n    # NVIDIA GPUs\n    GPU_V100 = \"gpu_v100\"\n    GPU_A100 = \"gpu_a100\"\n    GPU_H100 = \"gpu_h100\"\n    GPU_T4 = \"gpu_t4\"\n    GPU_A10G = \"gpu_a10g\"\n    \n    # CPUs\n    CPU_SMALL = \"cpu_small\"\n    CPU_MEDIUM = \"cpu_medium\"\n    CPU_LARGE = \"cpu_large\"\n    \n    # Storage\n    STORAGE_S3 = \"storage_s3\"\n    STORAGE_EBS = \"storage_ebs\"\n\n\nclass ComputeResource(BaseModel):\n    \"\"\"Compute resource specification\"\"\"\n    resource_type: ResourceType\n    quantity: int = 1\n    vcpu: Optional[int] = None\n    memory_gb: Optional[float] = None\n    gpu_memory_gb: Optional[float] = None\n\n\nclass ResourceUsage(BaseModel):\n    \"\"\"Resource usage record for a job\"\"\"\n    resource: ComputeResource\n    start_time: datetime\n    end_time: datetime\n    duration_seconds: float\n    duration_hours: float\n    avg_gpu_utilization: Optional[float] = None  # 0-100%\n    avg_memory_utilization: Optional[float] = None  # 0-100%\n    job_id: Optional[str] = None\n    model_name: Optional[str] = None\n    model_version: Optional[str] = None\n    tags: Dict[str, str] = {}\n\n\nclass TrainingCost(BaseModel):\n    \"\"\"Complete cost breakdown for a training job\"\"\"\n    job_id: str\n    model_name: str\n    model_version: str\n    start_time: datetime\n    end_time: datetime\n    duration_hours: float\n    resources: List[ResourceUsage]\n    \n    # Cost breakdown\n    compute_cost: float\n    storage_cost: float\n    network_cost: float\n    total_cost: float\n    \n    # Efficiency metrics\n    cost_per_epoch: Optional[float] = None\n    cost_per_sample: Optional[float] = None\n    \n    # Metadata\n    dataset_name: Optional[str] = None\n    dataset_size_gb: Optional[float] = None\n    num_samples: Optional[int] = None\n    num_epochs: Optional[int] = None\n    framework: Optional[str] = None\n    metadata: Dict = {}\n\n\nclass CostEstimate(BaseModel):\n    \"\"\"Cost estimate for planned training job\"\"\"\n    operation: Literal[\"training\", \"inference\"] = \"training\"\n    estimated_resources: List[ComputeResource]\n    estimated_duration_hours: float\n    estimated_compute_cost: float\n    estimated_storage_cost: float\n    estimated_network_cost: float\n    estimated_total_cost: float\n    confidence_level: Literal[\"low\", \"medium\", \"high\"] = \"medium\"\n    assumptions: List[str]\n    historical_similar_jobs: Optional[int] = None\n    avg_historical_cost: Optional[float] = None\n\n\nclass PricingInfo(BaseModel):\n    \"\"\"Pricing information for a resource\"\"\"\n    resource_type: ResourceType\n    price_per_hour: float\n    currency: str = \"USD\"\n    region: str = \"us-east-1\"\n    vcpu: Optional[int] = None\n    memory_gb: Optional[float] = None\n    gpu_memory_gb: Optional[float] = None\n    provider: Literal[\"aws\", \"azure\", \"gcp\"] = \"aws\"\n\n\n# ==================== Pricing Catalog ====================\nclass PricingCatalog:\n    \"\"\"Pricing catalog for different cloud providers\"\"\"\n\n    @staticmethod\n    def default_aws_pricing() -> 'PricingCatalog':\n        \"\"\"Get default AWS pricing (us-east-1, as of 2024)\"\"\"\n        catalog = PricingCatalog()\n        \n        # GPU instances (approximate)\n        catalog.pricing[ResourceType.GPU_V100] = PricingInfo(\n            resource_type=ResourceType.GPU_V100,\n            price_per_hour=3.06,\n            vcpu=8,\n            memory_gb=61,\n            gpu_memory_gb=16,\n            provider=\"aws\"\n        )\n        \n        catalog.pricing[ResourceType.GPU_A100] = PricingInfo(\n            resource_type=ResourceType.GPU_A100,\n            price_per_hour=4.10,\n            vcpu=16,\n            memory_gb=120,\n            gpu_memory_gb=40,\n            provider=\"aws\"\n        )\n        \n        catalog.pricing[ResourceType.GPU_H100] = PricingInfo(\n            resource_type=ResourceType.GPU_H100,\n            price_per_hour=8.0,  # Estimated\n            vcpu=24,\n            memory_gb=240,\n            gpu_memory_gb=80,\n            provider=\"aws\"\n        )\n        \n        catalog.pricing[ResourceType.GPU_T4] = PricingInfo(\n            resource_type=ResourceType.GPU_T4,\n            price_per_hour=0.526,\n            vcpu=4,\n            memory_gb=16,\n            gpu_memory_gb=16,\n            provider=\"aws\"\n        )\n        \n        # CPU instances\n        catalog.pricing[ResourceType.CPU_SMALL] = PricingInfo(\n            resource_type=ResourceType.CPU_SMALL,\n            price_per_hour=0.05,\n            vcpu=2,\n            memory_gb=4,\n            provider=\"aws\"\n        )\n        \n        catalog.pricing[ResourceType.CPU_MEDIUM] = PricingInfo(\n            resource_type=ResourceType.CPU_MEDIUM,\n            price_per_hour=0.2,\n            vcpu=8,\n            memory_gb=16,\n            provider=\"aws\"\n        )\n        \n        # Storage\n        catalog.pricing[ResourceType.STORAGE_S3] = PricingInfo(\n            resource_type=ResourceType.STORAGE_S3,\n            price_per_hour=0.023 / (24 * 30),  # $0.023/GB/month\n            provider=\"aws\"\n        )\n        \n        return catalog\n\n    def __init__(self):\n        self.pricing: Dict[ResourceType, PricingInfo] = {}\n\n    def get_compute_price(self, resource_type: ResourceType) -> Optional[PricingInfo]:\n        return self.pricing.get(resource_type)\n\n    def get_storage_price(self, resource_type: ResourceType) -> Optional[PricingInfo]:\n        return self.pricing.get(resource_type)\n\n    def get_network_price(self, egress_type: str = \"egress\") -> Optional[Dict]:\n        # Simple network pricing ($0.09/GB after 1GB free)\n        return {\"price_per_gb\": 0.09}\n\n\n# ==================== Training Cost Calculator ====================\nclass TrainingCostCalculator:\n    \"\"\"Calculate costs for ML model training jobs\"\"\"\n\n    def __init__(self, pricing_catalog: Optional[PricingCatalog] = None):\n        self.pricing = pricing_catalog or PricingCatalog.default_aws_pricing()\n        self.training_costs: Dict[str, TrainingCost] = {}\n\n    def calculate_job_cost(\n        self,\n        job_id: str,\n        model_name: str,\n        model_version: str,\n        resources: List[ResourceUsage],\n        start_time: Optional[datetime] = None,\n        end_time: Optional[datetime] = None,\n        num_epochs: Optional[int] = None,\n        num_samples: Optional[int] = None,\n        dataset_name: Optional[str] = None,\n        dataset_size_gb: Optional[float] = None,\n        storage_gb: float = 0.0,\n        network_egress_gb: float = 0.0,\n        framework: Optional[str] = None,\n        metadata: Optional[Dict] = None\n    ) -> TrainingCost:\n        \"\"\"\n        Calculate total cost for a training job\n\n        Args:\n            job_id: Training job identifier\n            model_name: Model being trained\n            model_version: Model version\n            resources: List of ResourceUsage records\n            start_time: Job start time (inferred if not provided)\n            end_time: Job end time (inferred if not provided)\n            num_epochs: Number of training epochs\n            num_samples: Number of training samples\n            storage_gb: Storage used in GB\n            network_egress_gb: Network transfer in GB\n            framework: ML framework (pytorch, tensorflow, etc)\n\n        Returns:\n            TrainingCost with complete breakdown\n        \"\"\"\n        if not resources:\n            raise ValueError(\"At least one ResourceUsage record required\")\n\n        # Infer time range\n        if start_time is None:\n            start_time = min(r.start_time for r in resources)\n        if end_time is None:\n            end_time = max(r.end_time for r in resources)\n\n        duration_hours = (end_time - start_time).total_seconds() / 3600\n\n        # Calculate costs\n        compute_cost = self._calculate_compute_cost(resources)\n        storage_cost = self._calculate_storage_cost(storage_gb, duration_hours)\n        network_cost = self._calculate_network_cost(network_egress_gb)\n        total_cost = compute_cost + storage_cost + network_cost\n\n        # Efficiency metrics\n        cost_per_epoch = total_cost / num_epochs if num_epochs and num_epochs > 0 else None\n        cost_per_sample = total_cost / num_samples if num_samples and num_samples > 0 else None\n\n        training_cost = TrainingCost(\n            job_id=job_id,\n            model_name=model_name,\n            model_version=model_version,\n            start_time=start_time,\n            end_time=end_time,\n            duration_hours=duration_hours,\n            resources=resources,\n            compute_cost=round(compute_cost, 4),\n            storage_cost=round(storage_cost, 4),\n            network_cost=round(network_cost, 4),\n            total_cost=round(total_cost, 4),\n            cost_per_epoch=round(cost_per_epoch, 4) if cost_per_epoch else None,\n            cost_per_sample=round(cost_per_sample, 6) if cost_per_sample else None,\n            dataset_name=dataset_name,\n            dataset_size_gb=dataset_size_gb,\n            num_samples=num_samples,\n            num_epochs=num_epochs,\n            framework=framework,\n            metadata=metadata or {}\n        )\n\n        # Store for future reference\n        self.training_costs[job_id] = training_cost\n        return training_cost\n\n    def estimate_training_cost(\n        self,\n        resource_type: ResourceType,\n        estimated_hours: float,\n        quantity: int = 1,\n        num_epochs: Optional[int] = None,\n        num_samples: Optional[int] = None,\n        storage_gb: float = 0.0,\n        network_egress_gb: float = 0.0,\n        similar_jobs: Optional[List[TrainingCost]] = None\n    ) -> CostEstimate:\n        \"\"\"\n        Estimate cost for a planned training job\n\n        Args:\n            resource_type: Type of compute resource\n            estimated_hours: Estimated duration\n            quantity: Number of resources\n            num_epochs: Number of epochs\n            num_samples: Number of samples\n            storage_gb: Storage needed\n            network_egress_gb: Network transfer\n            similar_jobs: Historical similar jobs for comparison\n\n        Returns:\n            CostEstimate with projected costs\n        \"\"\"\n        # Get pricing\n        compute_pricing = self.pricing.get_compute_price(resource_type)\n        if not compute_pricing:\n            raise ValueError(f\"No pricing found for {resource_type}\")\n\n        # Calculate estimates\n        estimated_compute_cost = compute_pricing.price_per_hour * estimated_hours * quantity\n        estimated_storage_cost = self._calculate_storage_cost(storage_gb, estimated_hours)\n        estimated_network_cost = self._calculate_network_cost(network_egress_gb)\n        estimated_total_cost = estimated_compute_cost + estimated_storage_cost + estimated_network_cost\n\n        # Build resource spec\n        resource = ComputeResource(\n            resource_type=resource_type,\n            quantity=quantity,\n            vcpu=compute_pricing.vcpu,\n            memory_gb=compute_pricing.memory_gb,\n            gpu_memory_gb=compute_pricing.gpu_memory_gb\n        )\n\n        # Determine confidence level\n        confidence = \"medium\"\n        if similar_jobs and len(similar_jobs) >= 5:\n            confidence = \"high\"\n        elif not similar_jobs or len(similar_jobs) == 0:\n            confidence = \"low\"\n\n        # Historical comparison\n        avg_historical_cost = None\n        if similar_jobs:\n            avg_historical_cost = sum(j.total_cost for j in similar_jobs) / len(similar_jobs)\n\n        # Build assumptions\n        assumptions = [\n            f\"Using {resource_type.value} at ${compute_pricing.price_per_hour:.3f}/hour\",\n            f\"Estimated duration: {estimated_hours:.1f} hours\",\n            f\"Quantity: {quantity} resource(s)\"\n        ]\n\n        if num_epochs:\n            assumptions.append(f\"Training for {num_epochs} epochs\")\n        if num_samples:\n            assumptions.append(f\"Dataset size: {num_samples:,} samples\")\n\n        return CostEstimate(\n            operation=\"training\",\n            estimated_resources=[resource],\n            estimated_duration_hours=estimated_hours,\n            estimated_compute_cost=round(estimated_compute_cost, 4),\n            estimated_storage_cost=round(estimated_storage_cost, 4),\n            estimated_network_cost=round(estimated_network_cost, 4),\n            estimated_total_cost=round(estimated_total_cost, 4),\n            confidence_level=confidence,\n            assumptions=assumptions,\n            historical_similar_jobs=len(similar_jobs) if similar_jobs else None,\n            avg_historical_cost=round(avg_historical_cost, 4) if avg_historical_cost else None\n        )\n\n    def _calculate_compute_cost(self, resources: List[ResourceUsage]) -> float:\n        \"\"\"Calculate total compute cost from resource usage\"\"\"\n        total_cost = 0.0\n\n        for usage in resources:\n            pricing = self.pricing.get_compute_price(usage.resource.resource_type)\n            if not pricing:\n                continue\n\n            resource_cost = pricing.price_per_hour * usage.duration_hours * usage.resource.quantity\n            total_cost += resource_cost\n\n        return total_cost\n\n    def _calculate_storage_cost(self, storage_gb: float, duration_hours: float) -> float:\n        \"\"\"Calculate storage cost\"\"\"\n        if storage_gb <= 0:\n            return 0.0\n\n        storage_pricing = self.pricing.get_storage_price(ResourceType.STORAGE_S3)\n        if not storage_pricing:\n            return 0.0\n\n        # Convert hourly to monthly\n        duration_months = duration_hours / (24 * 30)\n        return storage_pricing.price_per_hour * storage_gb * duration_months\n\n    def _calculate_network_cost(self, egress_gb: float) -> float:\n        \"\"\"Calculate network transfer cost\"\"\"\n        if egress_gb <= 0:\n            return 0.0\n\n        network_pricing = self.pricing.get_network_price(\"egress\")\n        if not network_pricing:\n            return 0.0\n\n        return network_pricing[\"price_per_gb\"] * egress_gb\n\n    def get_total_cost(\n        self,\n        model_name: Optional[str] = None,\n        start_time: Optional[datetime] = None,\n        end_time: Optional[datetime] = None\n    ) -> float:\n        \"\"\"Get total training costs with optional filters\"\"\"\n        total = 0.0\n\n        for cost in self.training_costs.values():\n            # Filter by model\n            if model_name and cost.model_name != model_name:\n                continue\n\n            # Filter by time range\n            if start_time and cost.end_time < start_time:\n                continue\n            if end_time and cost.start_time > end_time:\n                continue\n\n            total += cost.total_cost\n\n        return round(total, 2)\n\n\n# ==================== FastAPI Application ====================\nfrom fastapi import FastAPI, HTTPException\nfrom fastapi.responses import JSONResponse\n\napp = FastAPI(title=\"ML Cost Tracking API\")\n\n# Initialize calculator\ncalculator = TrainingCostCalculator()\n\n\nclass JobCostRequest(BaseModel):\n    job_id: str\n    model_name: str\n    model_version: str\n    resources: List[ResourceUsage]\n    num_epochs: Optional[int] = None\n    num_samples: Optional[int] = None\n    storage_gb: float = 0.0\n    network_egress_gb: float = 0.0\n    framework: Optional[str] = None\n\n\nclass CostEstimateRequest(BaseModel):\n    resource_type: ResourceType\n    estimated_hours: float\n    quantity: int = 1\n    num_epochs: Optional[int] = None\n    storage_gb: float = 0.0\n\n\n@app.post(\"/api/v1/costs/training\")\ndef calculate_training_cost(request: JobCostRequest):\n    \"\"\"\n    Calculate cost for completed training job\n    \"\"\"\n    try:\n        cost = calculator.calculate_job_cost(\n            job_id=request.job_id,\n            model_name=request.model_name,\n            model_version=request.model_version,\n            resources=request.resources,\n            num_epochs=request.num_epochs,\n            num_samples=request.num_samples,\n            storage_gb=request.storage_gb,\n            network_egress_gb=request.network_egress_gb,\n            framework=request.framework\n        )\n        return cost\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n\n@app.post(\"/api/v1/costs/estimate\")\ndef estimate_cost(request: CostEstimateRequest):\n    \"\"\"\n    Estimate cost for planned training job\n    \"\"\"\n    try:\n        estimate = calculator.estimate_training_cost(\n            resource_type=request.resource_type,\n            estimated_hours=request.estimated_hours,\n            quantity=request.quantity,\n            num_epochs=request.num_epochs,\n            storage_gb=request.storage_gb\n        )\n        return estimate\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n\n@app.get(\"/api/v1/costs/total\")\ndef get_total_costs(\n    model_name: Optional[str] = None,\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None\n):\n    \"\"\"\n    Get total costs with optional filters\n    \"\"\"\n    start_time = datetime.fromisoformat(start_date) if start_date else None\n    end_time = datetime.fromisoformat(end_date) if end_date else None\n    \n    total = calculator.get_total_cost(\n        model_name=model_name,\n        start_time=start_time,\n        end_time=end_time\n    )\n    \n    return {\"total_cost_usd\": total, \"currency\": \"USD\"}\n\n\n@app.get(\"/api/v1/pricing\")\ndef list_pricing():\n    \"\"\"\n    List available pricing for all resources\n    \"\"\"\n    return {\n        resource_type: pricing.dict()\n        for resource_type, pricing in calculator.pricing.pricing.items()\n    }\n\n\n@app.get(\"/health\")\ndef health_check():\n    return {\"status\": \"healthy\", \"service\": \"ml-cost-tracking\"}\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app, host=\"0.0.0.0\", port=8003)\n\n\n# ==================== Usage Example ====================\n\"\"\"\n# Calculate cost for completed job\nfrom datetime import datetime\n\nresource_usage = ResourceUsage(\n    resource=ComputeResource(\n        resource_type=ResourceType.GPU_A100,\n        quantity=4\n    ),\n    start_time=datetime(2025, 10, 13, 0, 0),\n    end_time=datetime(2025, 10, 13, 12, 0),\n    duration_seconds=43200,\n    duration_hours=12.0,\n    avg_gpu_utilization=85.0,\n    job_id=\"job-123\"\n)\n\ncost = calculator.calculate_job_cost(\n    job_id=\"job-123\",\n    model_name=\"bert-large\",\n    model_version=\"v2.0\",\n    resources=[resource_usage],\n    num_epochs=10,\n    num_samples=1000000,\n    storage_gb=500,\n    network_egress_gb=100,\n    framework=\"pytorch\"\n)\n\nprint(f\"Total Cost: ${cost.total_cost:.2f}\")\nprint(f\"Cost per Epoch: ${cost.cost_per_epoch:.2f}\")\nprint(f\"Cost per Sample: ${cost.cost_per_sample:.6f}\")\n\n# Estimate cost for planned job\nestimate = calculator.estimate_training_cost(\n    resource_type=ResourceType.GPU_A100,\n    estimated_hours=24.0,\n    quantity=8,\n    num_epochs=20,\n    num_samples=10000000,\n    storage_gb=1000\n)\n\nprint(f\"Estimated Total Cost: ${estimate.estimated_total_cost:.2f}\")\nprint(f\"Confidence: {estimate.confidence_level}\")\n\"\"\"\n",
  "variables": {
    "DEFAULT_CLOUD_PROVIDER": "aws",
    "DEFAULT_REGION": "us-east-1",
    "PRICING_UPDATE_INTERVAL_HOURS": "24",
    "COST_REPORTING_ENABLED": "true",
    "ALERT_THRESHOLD_USD": "1000.0"
  },
  "dependencies": [
    "fastapi>=0.109.0",
    "uvicorn[standard]>=0.27.0",
    "pydantic>=2.6.0",
    "python-dateutil>=2.8.2",
    "sqlalchemy>=2.0.0",
    "python-dotenv>=1.0.0"
  ],
  "workflow_context": {
    "typical_use_cases": [
      "ML training cost tracking and budgeting",
      "GPU resource cost optimization",
      "ML project cost forecasting",
      "Multi-cloud cost comparison",
      "Training efficiency analysis",
      "Cost per model metrics",
      "ML infrastructure budgeting"
    ],
    "team_composition": [
      "backend_developer",
      "ml_engineer",
      "devops_engineer",
      "solution_architect"
    ],
    "estimated_time_minutes": 150,
    "prerequisites": [
      "Understanding of ML training workflows",
      "Knowledge of GPU/CPU pricing models",
      "Cloud provider experience (AWS/Azure/GCP)",
      "FastAPI or similar framework knowledge",
      "Cost optimization awareness"
    ],
    "related_templates": [
      "ml-training-pipeline",
      "resource-monitoring",
      "cost-alerting",
      "budget-management",
      "multi-cloud-orchestration"
    ]
  }
}
