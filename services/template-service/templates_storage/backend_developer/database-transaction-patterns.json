{
  "metadata": {
    "id": "database-transactions-v1",
    "name": "Database Transaction Patterns (SQLAlchemy & TypeORM)",
    "category": "database",
    "language": "python",
    "framework": "sqlalchemy",
    "description": "Production-ready transaction management patterns including ACID transactions, distributed transactions, saga pattern, and rollback handling",
    "tags": [
      "transactions",
      "acid",
      "database",
      "sqlalchemy",
      "rollback",
      "distributed-transactions"
    ],
    "quality_score": 87.0,
    "security_score": 85.0,
    "performance_score": 88.0,
    "maintainability_score": 89.0,
    "test_coverage": 82.0,
    "usage_count": 0,
    "success_rate": 0.0,
    "status": "approved",
    "created_at": "2025-10-04T20:00:00.000000",
    "updated_at": "2025-10-04T20:00:00.000000",
    "created_by": "template_enhancement_phase1",
    "persona": "backend_developer"
  },
  "content": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine, async_sessionmaker\nfrom sqlalchemy import select, update, delete\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\nfrom sqlalchemy.exc import IntegrityError, SQLAlchemyError\nfrom contextlib import asynccontextmanager\nfrom typing import AsyncGenerator, TypeVar, Generic, Optional, Any, List\nfrom decimal import Decimal\nimport logging\nfrom datetime import datetime\n\nlogger = logging.getLogger(__name__)\n\nT = TypeVar('T')\n\nclass Base(DeclarativeBase):\n    pass\n\n# Example models\nclass Account(Base):\n    __tablename__ = \"accounts\"\n    \n    id: Mapped[int] = mapped_column(primary_key=True)\n    user_id: Mapped[int]\n    balance: Mapped[Decimal]\n    currency: Mapped[str]\n    version: Mapped[int] = mapped_column(default=0)  # For optimistic locking\n    updated_at: Mapped[datetime]\n\nclass Transaction(Base):\n    __tablename__ = \"transactions\"\n    \n    id: Mapped[int] = mapped_column(primary_key=True)\n    from_account_id: Mapped[int]\n    to_account_id: Mapped[int]\n    amount: Mapped[Decimal]\n    status: Mapped[str]  # pending, completed, failed\n    created_at: Mapped[datetime]\n\n# Database setup\nDATABASE_URL = \"postgresql+asyncpg://user:pass@localhost/dbname\"\nengine = create_async_engine(\n    DATABASE_URL,\n    echo=True,\n    pool_pre_ping=True,\n    pool_size=10,\n    max_overflow=20\n)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\n# Transaction Context Manager\n@asynccontextmanager\nasync def get_transaction_session() -> AsyncGenerator[AsyncSession, None]:\n    \"\"\"\n    Context manager for database transactions with automatic rollback on error\n    \"\"\"\n    async with async_session_maker() as session:\n        try:\n            async with session.begin():\n                yield session\n                # Commit happens automatically if no exception\n        except Exception as e:\n            logger.error(f\"Transaction failed, rolling back: {e}\")\n            # Rollback happens automatically\n            raise\n\n# Transaction Decorator\ndef transactional(func):\n    \"\"\"\n    Decorator to wrap function in a database transaction\n    \"\"\"\n    async def wrapper(*args, **kwargs):\n        async with get_transaction_session() as session:\n            # Inject session into function\n            return await func(*args, session=session, **kwargs)\n    return wrapper\n\n# Pattern 1: Simple Transaction\nclass TransactionService:\n    \"\"\"Service with various transaction patterns\"\"\"\n    \n    @staticmethod\n    async def simple_transaction_example(user_id: int, amount: Decimal) -> Account:\n        \"\"\"\n        Basic transaction with automatic rollback on error\n        \"\"\"\n        async with get_transaction_session() as session:\n            # Create new account\n            account = Account(\n                user_id=user_id,\n                balance=amount,\n                currency=\"USD\",\n                updated_at=datetime.utcnow()\n            )\n            session.add(account)\n            await session.flush()  # Get ID without committing\n            \n            logger.info(f\"Created account {account.id} with balance {amount}\")\n            return account\n    \n    # Pattern 2: Transfer with Optimistic Locking\n    @staticmethod\n    async def transfer_with_optimistic_lock(\n        from_account_id: int,\n        to_account_id: int,\n        amount: Decimal\n    ) -> Transaction:\n        \"\"\"\n        Money transfer with optimistic locking to prevent lost updates\n        \"\"\"\n        async with get_transaction_session() as session:\n            # Fetch accounts\n            from_account = await session.get(Account, from_account_id)\n            to_account = await session.get(Account, to_account_id)\n            \n            if not from_account or not to_account:\n                raise ValueError(\"Account not found\")\n            \n            if from_account.balance < amount:\n                raise ValueError(\"Insufficient funds\")\n            \n            # Store current versions for optimistic locking\n            from_version = from_account.version\n            to_version = to_account.version\n            \n            # Update balances\n            from_account.balance -= amount\n            from_account.version += 1\n            from_account.updated_at = datetime.utcnow()\n            \n            to_account.balance += amount\n            to_account.version += 1\n            to_account.updated_at = datetime.utcnow()\n            \n            # Verify versions haven't changed (optimistic locking)\n            result = await session.execute(\n                update(Account)\n                .where(\n                    Account.id == from_account_id,\n                    Account.version == from_version\n                )\n                .values(\n                    balance=from_account.balance,\n                    version=from_account.version,\n                    updated_at=from_account.updated_at\n                )\n            )\n            \n            if result.rowcount == 0:\n                raise ValueError(\"Account was modified by another transaction\")\n            \n            result = await session.execute(\n                update(Account)\n                .where(\n                    Account.id == to_account_id,\n                    Account.version == to_version\n                )\n                .values(\n                    balance=to_account.balance,\n                    version=to_account.version,\n                    updated_at=to_account.updated_at\n                )\n            )\n            \n            if result.rowcount == 0:\n                raise ValueError(\"Account was modified by another transaction\")\n            \n            # Create transaction record\n            transaction = Transaction(\n                from_account_id=from_account_id,\n                to_account_id=to_account_id,\n                amount=amount,\n                status=\"completed\",\n                created_at=datetime.utcnow()\n            )\n            session.add(transaction)\n            \n            logger.info(f\"Transfer completed: {amount} from {from_account_id} to {to_account_id}\")\n            return transaction\n    \n    # Pattern 3: Pessimistic Locking (SELECT FOR UPDATE)\n    @staticmethod\n    async def transfer_with_pessimistic_lock(\n        from_account_id: int,\n        to_account_id: int,\n        amount: Decimal\n    ) -> Transaction:\n        \"\"\"\n        Money transfer with pessimistic locking (row-level locks)\n        \"\"\"\n        async with get_transaction_session() as session:\n            # Lock rows for update (other transactions will wait)\n            result = await session.execute(\n                select(Account)\n                .where(Account.id.in_([from_account_id, to_account_id]))\n                .with_for_update()  # Pessimistic lock\n                .order_by(Account.id)  # Prevent deadlocks\n            )\n            accounts = {acc.id: acc for acc in result.scalars().all()}\n            \n            from_account = accounts.get(from_account_id)\n            to_account = accounts.get(to_account_id)\n            \n            if not from_account or not to_account:\n                raise ValueError(\"Account not found\")\n            \n            if from_account.balance < amount:\n                raise ValueError(\"Insufficient funds\")\n            \n            # Update balances (locked, safe to modify)\n            from_account.balance -= amount\n            to_account.balance += amount\n            from_account.updated_at = datetime.utcnow()\n            to_account.updated_at = datetime.utcnow()\n            \n            # Create transaction record\n            transaction = Transaction(\n                from_account_id=from_account_id,\n                to_account_id=to_account_id,\n                amount=amount,\n                status=\"completed\",\n                created_at=datetime.utcnow()\n            )\n            session.add(transaction)\n            \n            return transaction\n    \n    # Pattern 4: Savepoint for Nested Transactions\n    @staticmethod\n    async def nested_transaction_with_savepoint(\n        operations: List[dict]\n    ) -> List[Transaction]:\n        \"\"\"\n        Execute multiple operations with savepoints for partial rollback\n        \"\"\"\n        results = []\n        \n        async with get_transaction_session() as session:\n            for i, op in enumerate(operations):\n                # Create savepoint\n                savepoint = await session.begin_nested()\n                \n                try:\n                    # Execute operation\n                    transaction = Transaction(\n                        from_account_id=op[\"from\"],\n                        to_account_id=op[\"to\"],\n                        amount=op[\"amount\"],\n                        status=\"completed\",\n                        created_at=datetime.utcnow()\n                    )\n                    session.add(transaction)\n                    \n                    # Update accounts\n                    await session.execute(\n                        update(Account)\n                        .where(Account.id == op[\"from\"])\n                        .values(balance=Account.balance - op[\"amount\"])\n                    )\n                    await session.execute(\n                        update(Account)\n                        .where(Account.id == op[\"to\"])\n                        .values(balance=Account.balance + op[\"amount\"])\n                    )\n                    \n                    await savepoint.commit()\n                    results.append(transaction)\n                    logger.info(f\"Operation {i} completed\")\n                    \n                except Exception as e:\n                    # Rollback to savepoint (only this operation)\n                    await savepoint.rollback()\n                    logger.warning(f\"Operation {i} failed: {e}\")\n                    continue\n            \n            return results\n    \n    # Pattern 5: Two-Phase Commit Simulation (Saga Pattern)\n    @staticmethod\n    async def distributed_transaction_saga(\n        from_account_id: int,\n        to_account_id: int,\n        amount: Decimal\n    ) -> Transaction:\n        \"\"\"\n        Saga pattern for distributed transactions with compensating actions\n        \"\"\"\n        compensation_stack = []\n        \n        try:\n            # Phase 1: Debit\n            async with get_transaction_session() as session:\n                result = await session.execute(\n                    update(Account)\n                    .where(Account.id == from_account_id)\n                    .values(balance=Account.balance - amount)\n                )\n                \n                if result.rowcount == 0:\n                    raise ValueError(\"Failed to debit account\")\n                \n                # Add compensation\n                compensation_stack.append((\n                    \"credit\",\n                    from_account_id,\n                    amount\n                ))\n            \n            # Phase 2: Credit\n            async with get_transaction_session() as session:\n                result = await session.execute(\n                    update(Account)\n                    .where(Account.id == to_account_id)\n                    .values(balance=Account.balance + amount)\n                )\n                \n                if result.rowcount == 0:\n                    raise ValueError(\"Failed to credit account\")\n            \n            # Phase 3: Record transaction\n            async with get_transaction_session() as session:\n                transaction = Transaction(\n                    from_account_id=from_account_id,\n                    to_account_id=to_account_id,\n                    amount=amount,\n                    status=\"completed\",\n                    created_at=datetime.utcnow()\n                )\n                session.add(transaction)\n                return transaction\n                \n        except Exception as e:\n            logger.error(f\"Saga failed, executing compensations: {e}\")\n            \n            # Execute compensating transactions in reverse order\n            for action, account_id, comp_amount in reversed(compensation_stack):\n                try:\n                    async with get_transaction_session() as session:\n                        if action == \"credit\":\n                            await session.execute(\n                                update(Account)\n                                .where(Account.id == account_id)\n                                .values(balance=Account.balance + comp_amount)\n                            )\n                        logger.info(f\"Compensation executed for account {account_id}\")\n                except Exception as comp_error:\n                    logger.error(f\"Compensation failed: {comp_error}\")\n            \n            raise\n\n# TypeORM version (TypeScript)\n/*\nimport { DataSource, EntityManager } from 'typeorm';\n\nclass TransactionService {\n  constructor(private dataSource: DataSource) {}\n\n  async simpleTransaction(userId: number, amount: number): Promise<Account> {\n    return await this.dataSource.transaction(async (manager: EntityManager) => {\n      const account = manager.create(Account, {\n        userId,\n        balance: amount,\n        currency: 'USD',\n      });\n      return await manager.save(account);\n    });\n  }\n\n  async transferWithLock(\n    fromId: number,\n    toId: number,\n    amount: number,\n  ): Promise<Transaction> {\n    return await this.dataSource.transaction('SERIALIZABLE', async (manager) => {\n      const accounts = await manager\n        .createQueryBuilder(Account, 'account')\n        .where('account.id IN (:...ids)', { ids: [fromId, toId] })\n        .setLock('pessimistic_write')\n        .orderBy('account.id', 'ASC')\n        .getMany();\n\n      const fromAccount = accounts.find((a) => a.id === fromId);\n      const toAccount = accounts.find((a) => a.id === toId);\n\n      if (!fromAccount || !toAccount) {\n        throw new Error('Account not found');\n      }\n\n      if (fromAccount.balance < amount) {\n        throw new Error('Insufficient funds');\n      }\n\n      fromAccount.balance -= amount;\n      toAccount.balance += amount;\n\n      await manager.save([fromAccount, toAccount]);\n\n      const transaction = manager.create(Transaction, {\n        fromAccountId: fromId,\n        toAccountId: toId,\n        amount,\n        status: 'completed',\n      });\n\n      return await manager.save(transaction);\n    });\n  }\n}\n*/",
  "variables": {
    "DATABASE_URL": "postgresql+asyncpg://user:pass@localhost/dbname",
    "ISOLATION_LEVEL": "READ COMMITTED"
  },
  "dependencies": [
    "sqlalchemy[asyncio]==2.0.25",
    "asyncpg==0.29.0"
  ],
  "workflow_context": {
    "typical_use_cases": [
      "Financial transactions",
      "Inventory management",
      "Order processing",
      "Account balance updates",
      "Distributed transactions"
    ],
    "team_composition": [
      "backend_developer",
      "database_specialist"
    ],
    "estimated_time_minutes": 70,
    "prerequisites": [
      "Understanding of ACID properties",
      "Knowledge of database locking mechanisms",
      "Familiarity with transaction isolation levels",
      "PostgreSQL or MySQL database"
    ],
    "related_templates": [
      "database-indexing-strategies",
      "optimistic-vs-pessimistic-locking",
      "saga-pattern-implementation"
    ]
  }
}
