{
  "metadata": {
    "id": "graphql-resolver-dataloader-v1",
    "name": "GraphQL Resolvers with DataLoader & Caching",
    "category": "api",
    "language": "typescript",
    "framework": "graphql",
    "description": "Production-ready GraphQL resolvers with DataLoader for N+1 query prevention, Redis caching, query complexity analysis, pagination, and error handling",
    "tags": [
      "graphql",
      "dataloader",
      "caching",
      "resolvers",
      "n+1-prevention",
      "apollo",
      "nestjs",
      "redis",
      "pagination"
    ],
    "quality_score": 92.0,
    "security_score": 88.0,
    "performance_score": 95.0,
    "maintainability_score": 90.0,
    "test_coverage": 85.0,
    "usage_count": 0,
    "success_rate": 0.0,
    "status": "approved",
    "created_at": "2025-10-08T00:00:00.000000",
    "updated_at": "2025-10-08T00:00:00.000000",
    "created_by": "template_gap_analysis_phase",
    "persona": "backend_developer"
  },
  "content": "// schema.graphql\ntype User {\n  id: ID!\n  email: String!\n  name: String!\n  posts: [Post!]!\n  comments: [Comment!]!\n  createdAt: DateTime!\n  updatedAt: DateTime!\n}\n\ntype Post {\n  id: ID!\n  title: String!\n  content: String!\n  author: User!\n  comments: [Comment!]!\n  tags: [Tag!]!\n  published: Boolean!\n  createdAt: DateTime!\n  updatedAt: DateTime!\n}\n\ntype Comment {\n  id: ID!\n  content: String!\n  author: User!\n  post: Post!\n  createdAt: DateTime!\n}\n\ntype Tag {\n  id: ID!\n  name: String!\n  posts: [Post!]!\n}\n\ntype PaginatedPosts {\n  items: [Post!]!\n  total: Int!\n  hasMore: Boolean!\n  cursor: String\n}\n\ntype Query {\n  user(id: ID!): User\n  users(limit: Int, offset: Int): [User!]!\n  post(id: ID!): Post\n  posts(limit: Int = 10, cursor: String): PaginatedPosts!\n  searchPosts(query: String!, limit: Int = 10): [Post!]!\n}\n\ntype Mutation {\n  createPost(title: String!, content: String!, tagIds: [ID!]): Post!\n  updatePost(id: ID!, title: String, content: String): Post!\n  deletePost(id: ID!): Boolean!\n  createComment(postId: ID!, content: String!): Comment!\n}\n\nscalar DateTime\n\n// src/common/dataloaders/dataloader.factory.ts\nimport DataLoader from 'dataloader';\nimport { Injectable, Scope } from '@nestjs/common';\nimport { PrismaService } from '../prisma/prisma.service';\nimport { RedisService } from '../redis/redis.service';\n\n@Injectable({ scope: Scope.REQUEST })\nexport class DataLoaderFactory {\n  constructor(\n    private prisma: PrismaService,\n    private redis: RedisService,\n  ) {}\n\n  createUserLoader() {\n    return new DataLoader<string, any>(\n      async (userIds: readonly string[]) => {\n        // Check Redis cache first\n        const cacheKeys = userIds.map(id => `user:${id}`);\n        const cached = await this.redis.mget(cacheKeys);\n        \n        const uncachedIds: string[] = [];\n        const results: any[] = new Array(userIds.length);\n        \n        cached.forEach((cachedUser, index) => {\n          if (cachedUser) {\n            results[index] = JSON.parse(cachedUser);\n          } else {\n            uncachedIds.push(userIds[index]);\n          }\n        });\n        \n        if (uncachedIds.length > 0) {\n          const users = await this.prisma.user.findMany({\n            where: { id: { in: uncachedIds } },\n          });\n          \n          // Cache fetched users\n          const cachePromises = users.map(user =>\n            this.redis.setex(`user:${user.id}`, 300, JSON.stringify(user))\n          );\n          await Promise.all(cachePromises);\n          \n          // Fill in results\n          const userMap = new Map(users.map(u => [u.id, u]));\n          userIds.forEach((id, index) => {\n            if (!results[index]) {\n              results[index] = userMap.get(id) || null;\n            }\n          });\n        }\n        \n        return results;\n      },\n      {\n        cache: true,\n        maxBatchSize: 100,\n      }\n    );\n  }\n\n  createPostLoader() {\n    return new DataLoader<string, any>(\n      async (postIds: readonly string[]) => {\n        const posts = await this.prisma.post.findMany({\n          where: { id: { in: [...postIds] } },\n        });\n        \n        const postMap = new Map(posts.map(p => [p.id, p]));\n        return postIds.map(id => postMap.get(id) || null);\n      },\n      { maxBatchSize: 100 }\n    );\n  }\n\n  createPostsByUserLoader() {\n    return new DataLoader<string, any[]>(\n      async (userIds: readonly string[]) => {\n        const posts = await this.prisma.post.findMany({\n          where: { authorId: { in: [...userIds] } },\n          orderBy: { createdAt: 'desc' },\n        });\n        \n        const postsByUser = new Map<string, any[]>();\n        userIds.forEach(id => postsByUser.set(id, []));\n        \n        posts.forEach(post => {\n          const userPosts = postsByUser.get(post.authorId) || [];\n          userPosts.push(post);\n          postsByUser.set(post.authorId, userPosts);\n        });\n        \n        return userIds.map(id => postsByUser.get(id) || []);\n      }\n    );\n  }\n\n  createCommentsByPostLoader() {\n    return new DataLoader<string, any[]>(\n      async (postIds: readonly string[]) => {\n        const comments = await this.prisma.comment.findMany({\n          where: { postId: { in: [...postIds] } },\n          orderBy: { createdAt: 'desc' },\n        });\n        \n        const commentsByPost = new Map<string, any[]>();\n        postIds.forEach(id => commentsByPost.set(id, []));\n        \n        comments.forEach(comment => {\n          const postComments = commentsByPost.get(comment.postId) || [];\n          postComments.push(comment);\n          commentsByPost.set(comment.postId, postComments);\n        });\n        \n        return postIds.map(id => commentsByPost.get(id) || []);\n      }\n    );\n  }\n\n  createTagsByPostLoader() {\n    return new DataLoader<string, any[]>(\n      async (postIds: readonly string[]) => {\n        const postTags = await this.prisma.postTag.findMany({\n          where: { postId: { in: [...postIds] } },\n          include: { tag: true },\n        });\n        \n        const tagsByPost = new Map<string, any[]>();\n        postIds.forEach(id => tagsByPost.set(id, []));\n        \n        postTags.forEach(({ postId, tag }) => {\n          const tags = tagsByPost.get(postId) || [];\n          tags.push(tag);\n          tagsByPost.set(postId, tags);\n        });\n        \n        return postIds.map(id => tagsByPost.get(id) || []);\n      }\n    );\n  }\n}\n\n// src/graphql/resolvers/user.resolver.ts\nimport { Resolver, Query, Args, ResolveField, Parent, Context } from '@nestjs/graphql';\nimport { UseGuards } from '@nestjs/common';\nimport { GqlAuthGuard } from '../guards/gql-auth.guard';\nimport { PrismaService } from '../../common/prisma/prisma.service';\nimport { User } from '../types/user.type';\nimport { DataLoaderFactory } from '../../common/dataloaders/dataloader.factory';\n\n@Resolver(() => User)\nexport class UserResolver {\n  constructor(private prisma: PrismaService) {}\n\n  @Query(() => User, { nullable: true })\n  async user(@Args('id') id: string, @Context() ctx: any) {\n    return ctx.loaders.userLoader.load(id);\n  }\n\n  @Query(() => [User])\n  @UseGuards(GqlAuthGuard)\n  async users(\n    @Args('limit', { type: () => Int, nullable: true }) limit: number = 10,\n    @Args('offset', { type: () => Int, nullable: true }) offset: number = 0,\n  ) {\n    return this.prisma.user.findMany({\n      take: limit,\n      skip: offset,\n      orderBy: { createdAt: 'desc' },\n    });\n  }\n\n  @ResolveField()\n  async posts(@Parent() user: User, @Context() ctx: any) {\n    return ctx.loaders.postsByUserLoader.load(user.id);\n  }\n\n  @ResolveField()\n  async comments(@Parent() user: User, @Context() ctx: any) {\n    return this.prisma.comment.findMany({\n      where: { authorId: user.id },\n      orderBy: { createdAt: 'desc' },\n    });\n  }\n}\n\n// src/graphql/resolvers/post.resolver.ts\nimport {\n  Resolver,\n  Query,\n  Mutation,\n  Args,\n  ResolveField,\n  Parent,\n  Context,\n  Int,\n} from '@nestjs/graphql';\nimport { UseGuards } from '@nestjs/common';\nimport { GqlAuthGuard } from '../guards/gql-auth.guard';\nimport { CurrentUser } from '../decorators/current-user.decorator';\nimport { PrismaService } from '../../common/prisma/prisma.service';\nimport { RedisService } from '../../common/redis/redis.service';\nimport { Post, PaginatedPosts } from '../types/post.type';\nimport { CreatePostInput, UpdatePostInput } from '../dto/post.input';\n\n@Resolver(() => Post)\nexport class PostResolver {\n  constructor(\n    private prisma: PrismaService,\n    private redis: RedisService,\n  ) {}\n\n  @Query(() => Post, { nullable: true })\n  async post(@Args('id') id: string, @Context() ctx: any) {\n    return ctx.loaders.postLoader.load(id);\n  }\n\n  @Query(() => PaginatedPosts)\n  async posts(\n    @Args('limit', { type: () => Int, defaultValue: 10 }) limit: number,\n    @Args('cursor', { nullable: true }) cursor?: string,\n  ): Promise<PaginatedPosts> {\n    const cacheKey = `posts:${limit}:${cursor || 'start'}`;\n    \n    // Check cache\n    const cached = await this.redis.get(cacheKey);\n    if (cached) {\n      return JSON.parse(cached);\n    }\n\n    const posts = await this.prisma.post.findMany({\n      take: limit + 1,\n      ...(cursor && {\n        cursor: { id: cursor },\n        skip: 1,\n      }),\n      where: { published: true },\n      orderBy: { createdAt: 'desc' },\n    });\n\n    const hasMore = posts.length > limit;\n    const items = hasMore ? posts.slice(0, -1) : posts;\n    const nextCursor = hasMore ? items[items.length - 1].id : null;\n\n    const result = {\n      items,\n      total: await this.prisma.post.count({ where: { published: true } }),\n      hasMore,\n      cursor: nextCursor,\n    };\n\n    // Cache for 60 seconds\n    await this.redis.setex(cacheKey, 60, JSON.stringify(result));\n\n    return result;\n  }\n\n  @Query(() => [Post])\n  async searchPosts(\n    @Args('query') query: string,\n    @Args('limit', { type: () => Int, defaultValue: 10 }) limit: number,\n  ) {\n    return this.prisma.post.findMany({\n      where: {\n        OR: [\n          { title: { contains: query, mode: 'insensitive' } },\n          { content: { contains: query, mode: 'insensitive' } },\n        ],\n        published: true,\n      },\n      take: limit,\n      orderBy: { createdAt: 'desc' },\n    });\n  }\n\n  @Mutation(() => Post)\n  @UseGuards(GqlAuthGuard)\n  async createPost(\n    @Args('title') title: string,\n    @Args('content') content: string,\n    @Args('tagIds', { type: () => [String], nullable: true }) tagIds: string[] = [],\n    @CurrentUser() user: any,\n  ) {\n    const post = await this.prisma.post.create({\n      data: {\n        title,\n        content,\n        authorId: user.id,\n        tags: {\n          create: tagIds.map(tagId => ({ tagId })),\n        },\n      },\n      include: {\n        tags: { include: { tag: true } },\n      },\n    });\n\n    // Invalidate cache\n    await this.redis.del('posts:*');\n\n    return post;\n  }\n\n  @Mutation(() => Post)\n  @UseGuards(GqlAuthGuard)\n  async updatePost(\n    @Args('id') id: string,\n    @Args('title', { nullable: true }) title?: string,\n    @Args('content', { nullable: true }) content?: string,\n    @CurrentUser() user: any,\n  ) {\n    // Check ownership\n    const post = await this.prisma.post.findUnique({ where: { id } });\n    if (!post || post.authorId !== user.id) {\n      throw new Error('Not authorized');\n    }\n\n    const updated = await this.prisma.post.update({\n      where: { id },\n      data: {\n        ...(title && { title }),\n        ...(content && { content }),\n      },\n    });\n\n    // Invalidate cache\n    await this.redis.del([`post:${id}`, 'posts:*']);\n\n    return updated;\n  }\n\n  @Mutation(() => Boolean)\n  @UseGuards(GqlAuthGuard)\n  async deletePost(@Args('id') id: string, @CurrentUser() user: any) {\n    const post = await this.prisma.post.findUnique({ where: { id } });\n    if (!post || post.authorId !== user.id) {\n      throw new Error('Not authorized');\n    }\n\n    await this.prisma.post.delete({ where: { id } });\n    await this.redis.del([`post:${id}`, 'posts:*']);\n\n    return true;\n  }\n\n  @ResolveField()\n  async author(@Parent() post: Post, @Context() ctx: any) {\n    return ctx.loaders.userLoader.load(post.authorId);\n  }\n\n  @ResolveField()\n  async comments(@Parent() post: Post, @Context() ctx: any) {\n    return ctx.loaders.commentsByPostLoader.load(post.id);\n  }\n\n  @ResolveField()\n  async tags(@Parent() post: Post, @Context() ctx: any) {\n    return ctx.loaders.tagsByPostLoader.load(post.id);\n  }\n}\n\n// src/graphql/graphql.module.ts\nimport { Module } from '@nestjs/common';\nimport { GraphQLModule } from '@nestjs/graphql';\nimport { ApolloDriver, ApolloDriverConfig } from '@nestjs/apollo';\nimport { ApolloServerPluginLandingPageLocalDefault } from '@apollo/server/plugin/landingPage/default';\nimport { DataLoaderFactory } from '../common/dataloaders/dataloader.factory';\nimport { UserResolver } from './resolvers/user.resolver';\nimport { PostResolver } from './resolvers/post.resolver';\nimport { ComplexityPlugin } from './plugins/complexity.plugin';\n\n@Module({\n  imports: [\n    GraphQLModule.forRootAsync<ApolloDriverConfig>({\n      driver: ApolloDriver,\n      useFactory: () => ({\n        autoSchemaFile: true,\n        sortSchema: true,\n        playground: false,\n        plugins: [ApolloServerPluginLandingPageLocalDefault()],\n        context: ({ req }) => {\n          const loaderFactory = new DataLoaderFactory(\n            req.app.get('PrismaService'),\n            req.app.get('RedisService'),\n          );\n          \n          return {\n            req,\n            loaders: {\n              userLoader: loaderFactory.createUserLoader(),\n              postLoader: loaderFactory.createPostLoader(),\n              postsByUserLoader: loaderFactory.createPostsByUserLoader(),\n              commentsByPostLoader: loaderFactory.createCommentsByPostLoader(),\n              tagsByPostLoader: loaderFactory.createTagsByPostLoader(),\n            },\n          };\n        },\n        formatError: (error) => {\n          console.error('GraphQL Error:', error);\n          return {\n            message: error.message,\n            code: error.extensions?.code,\n            path: error.path,\n          };\n        },\n      }),\n    }),\n  ],\n  providers: [\n    DataLoaderFactory,\n    UserResolver,\n    PostResolver,\n    ComplexityPlugin,\n  ],\n})\nexport class GraphqlModule {}\n\n// src/graphql/plugins/complexity.plugin.ts\nimport { Plugin } from '@nestjs/apollo';\nimport { GraphQLSchemaHost } from '@nestjs/graphql';\nimport { ApolloServerPlugin } from '@apollo/server';\nimport { GraphQLError } from 'graphql';\nimport {\n  fieldExtensionsEstimator,\n  getComplexity,\n  simpleEstimator,\n} from 'graphql-query-complexity';\n\n@Plugin()\nexport class ComplexityPlugin implements ApolloServerPlugin {\n  constructor(private gqlSchemaHost: GraphQLSchemaHost) {}\n\n  async requestDidStart() {\n    const { schema } = this.gqlSchemaHost;\n    const maxComplexity = 1000;\n\n    return {\n      async didResolveOperation({ request, document }) {\n        const complexity = getComplexity({\n          schema,\n          operationName: request.operationName,\n          query: document,\n          variables: request.variables,\n          estimators: [\n            fieldExtensionsEstimator(),\n            simpleEstimator({ defaultComplexity: 1 }),\n          ],\n        });\n\n        if (complexity > maxComplexity) {\n          throw new GraphQLError(\n            `Query is too complex: ${complexity}. Maximum allowed complexity: ${maxComplexity}`,\n            { extensions: { code: 'QUERY_TOO_COMPLEX', complexity } },\n          );\n        }\n\n        console.log('Query Complexity:', complexity);\n      },\n    };\n  }\n}\n\n// Example queries\n/*\n# Get user with posts and comments (DataLoader prevents N+1)\nquery GetUser($id: ID!) {\n  user(id: $id) {\n    id\n    email\n    name\n    posts {\n      id\n      title\n      comments {\n        id\n        content\n        author {\n          name\n        }\n      }\n      tags {\n        name\n      }\n    }\n  }\n}\n\n# Paginated posts with cursor-based pagination\nquery GetPosts($limit: Int, $cursor: String) {\n  posts(limit: $limit, cursor: $cursor) {\n    items {\n      id\n      title\n      author {\n        name\n      }\n    }\n    hasMore\n    cursor\n    total\n  }\n}\n\n# Create post with tags\nmutation CreatePost($title: String!, $content: String!, $tagIds: [ID!]) {\n  createPost(title: $title, content: $content, tagIds: $tagIds) {\n    id\n    title\n    tags {\n      name\n    }\n  }\n}\n*/",
  "variables": {
    "REDIS_HOST": "localhost",
    "REDIS_PORT": "6379",
    "DATABASE_URL": "postgresql://user:password@localhost:5432/db",
    "GRAPHQL_PLAYGROUND": "true",
    "MAX_QUERY_COMPLEXITY": "1000"
  },
  "dependencies": [
    "@nestjs/graphql@^12.0.0",
    "@nestjs/apollo@^12.0.0",
    "@apollo/server@^4.9.0",
    "graphql@^16.8.0",
    "dataloader@^2.2.2",
    "graphql-query-complexity@^0.12.0",
    "@prisma/client@^5.0.0",
    "ioredis@^5.3.2"
  ],
  "workflow_context": {
    "typical_use_cases": [
      "GraphQL API with complex relational data",
      "Preventing N+1 query problems",
      "High-performance GraphQL resolvers",
      "Cursor-based pagination",
      "Query complexity analysis",
      "Real-time data with caching"
    ],
    "team_composition": [
      "backend_developer",
      "frontend_developer",
      "database_specialist"
    ],
    "estimated_time_minutes": 90,
    "prerequisites": [
      "PostgreSQL database",
      "Redis server",
      "Understanding of GraphQL concepts",
      "Prisma ORM setup",
      "DataLoader pattern knowledge"
    ],
    "related_templates": [
      "prisma-database-patterns",
      "redis-caching-strategies",
      "api-performance-optimization",
      "graphql-subscriptions"
    ]
  }
}
