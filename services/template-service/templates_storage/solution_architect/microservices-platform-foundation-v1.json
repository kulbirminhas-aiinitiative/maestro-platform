{
  "metadata": {
    "id": "microservices-platform-foundation-v1",
    "name": "Microservices Platform Foundation",
    "category": "architecture",
    "language": "python",
    "framework": "fastapi",
    "description": "Production-ready microservices platform foundation with API gateway, service mesh capabilities, rate limiting, JWT authentication, request routing, load balancing, distributed tracing, metrics collection, and service discovery",
    "tags": [
      "microservices",
      "api-gateway",
      "service-mesh",
      "rate-limiting",
      "jwt-auth",
      "load-balancing",
      "distributed-tracing",
      "service-discovery",
      "observability",
      "opentelemetry",
      "consul",
      "redis",
      "fastapi"
    ],
    "quality_score": 93.0,
    "security_score": 92.0,
    "performance_score": 90.0,
    "maintainability_score": 91.0,
    "test_coverage": 87.0,
    "usage_count": 0,
    "success_rate": 0.0,
    "status": "approved",
    "created_at": "2025-10-09T00:00:00Z",
    "updated_at": "2025-10-09T00:00:00Z",
    "created_by": "gap_analysis_tg-005",
    "persona": "solution_architect"
  },
  "content": "#!/usr/bin/env python3\n\"\"\"\nMicroservices Platform Foundation - API Gateway with Service Mesh Capabilities\n\nProduction-ready platform providing:\n- API Gateway with intelligent routing\n- Rate limiting (token bucket algorithm)\n- JWT authentication and authorization\n- Load balancing across service instances\n- Service discovery (Consul integration)\n- Distributed tracing (OpenTelemetry)\n- Metrics collection (Prometheus format)\n- Health checking and circuit breaking\n- Request/response transformation\n- API versioning support\n\nArchitecture:\n- FastAPI for high-performance async gateway\n- Redis for rate limiting and caching\n- Consul for service discovery\n- OpenTelemetry for observability\n- JWT for stateless authentication\n- Prometheus metrics endpoint\n\"\"\"\n\nimport asyncio\nimport hashlib\nimport logging\nimport os\nimport random\nimport time\nimport uuid\nfrom datetime import datetime, timedelta\nfrom typing import Any, Callable, Dict, List, Optional\nfrom enum import Enum\n\nimport httpx\nimport jwt\nimport redis.asyncio as redis\nfrom fastapi import FastAPI, HTTPException, Request, Response, Depends, Header\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.responses import JSONResponse\nfrom opentelemetry import trace, metrics\nfrom opentelemetry.exporter.prometheus import PrometheusMetricReader\nfrom opentelemetry.sdk.metrics import MeterProvider\nfrom opentelemetry.sdk.resources import Resource\nfrom opentelemetry.sdk.trace import TracerProvider\nfrom opentelemetry.sdk.trace.export import BatchSpanProcessor, ConsoleSpanExporter\nfrom opentelemetry.trace import Status, StatusCode\nfrom prometheus_client import REGISTRY, Counter, Histogram, Gauge, generate_latest\nfrom pydantic import BaseModel, Field\nimport uvicorn\n\n# Configuration\nJWT_SECRET = os.getenv(\"JWT_SECRET\", \"your-secret-key-change-in-production\")\nJWT_ALGORITHM = os.getenv(\"JWT_ALGORITHM\", \"HS256\")\nJWT_EXPIRATION_HOURS = int(os.getenv(\"JWT_EXPIRATION_HOURS\", \"24\"))\n\nREDIS_URL = os.getenv(\"REDIS_URL\", \"redis://localhost:6379\")\n\nCONSUL_HOST = os.getenv(\"CONSUL_HOST\", \"localhost\")\nCONSUL_PORT = int(os.getenv(\"CONSUL_PORT\", \"8500\"))\n\n# Rate limiting\nRATE_LIMIT_REQUESTS = int(os.getenv(\"RATE_LIMIT_REQUESTS\", \"100\"))\nRATE_LIMIT_WINDOW_SECONDS = int(os.getenv(\"RATE_LIMIT_WINDOW_SECONDS\", \"60\"))\n\n# Circuit breaker\nCIRCUIT_BREAKER_THRESHOLD = int(os.getenv(\"CIRCUIT_BREAKER_THRESHOLD\", \"5\"))\nCIRCUIT_BREAKER_TIMEOUT_SECONDS = int(os.getenv(\"CIRCUIT_BREAKER_TIMEOUT_SECONDS\", \"60\"))\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\n# Prometheus Metrics\nrequest_count = Counter(\n    \"gateway_requests_total\", \"Total gateway requests\", [\"method\", \"path\", \"status\"]\n)\nrequest_duration = Histogram(\n    \"gateway_request_duration_seconds\", \"Request duration\", [\"method\", \"path\"]\n)\nactive_requests = Gauge(\"gateway_active_requests\", \"Active requests\")\nservice_health = Gauge(\"service_health\", \"Service health status\", [\"service\"])\nrate_limit_hits = Counter(\"rate_limit_hits_total\", \"Rate limit hits\", [\"client_id\"])\n\n\n# Models\nclass ServiceStatus(str, Enum):\n    HEALTHY = \"healthy\"\n    UNHEALTHY = \"unhealthy\"\n    UNKNOWN = \"unknown\"\n\n\nclass ServiceInstance(BaseModel):\n    service_id: str\n    service_name: str\n    host: str\n    port: int\n    health_check_url: Optional[str] = None\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n    status: ServiceStatus = ServiceStatus.UNKNOWN\n    last_health_check: Optional[datetime] = None\n\n\nclass RouteConfig(BaseModel):\n    path_prefix: str\n    service_name: str\n    strip_prefix: bool = True\n    rate_limit: Optional[int] = None\n    auth_required: bool = True\n    timeout_seconds: int = 30\n    retry_count: int = 3\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n\n\nclass JWTToken(BaseModel):\n    sub: str  # Subject (user ID)\n    scopes: List[str] = Field(default_factory=list)\n    exp: Optional[int] = None\n\n\nclass CircuitBreakerState(str, Enum):\n    CLOSED = \"closed\"  # Normal operation\n    OPEN = \"open\"  # Failing, reject requests\n    HALF_OPEN = \"half_open\"  # Testing if service recovered\n\n\n# Service Registry (Consul Integration)\nclass ServiceRegistry:\n    \"\"\"Service discovery and registration using Consul\"\"\"\n\n    def __init__(self, consul_host: str = CONSUL_HOST, consul_port: int = CONSUL_PORT):\n        self.consul_url = f\"http://{consul_host}:{consul_port}\"\n        self.services: Dict[str, List[ServiceInstance]] = {}\n        self.client = httpx.AsyncClient(timeout=10.0)\n\n    async def register_service(self, instance: ServiceInstance):\n        \"\"\"Register service instance with Consul\"\"\"\n        try:\n            service_data = {\n                \"ID\": instance.service_id,\n                \"Name\": instance.service_name,\n                \"Address\": instance.host,\n                \"Port\": instance.port,\n                \"Check\": {\n                    \"HTTP\": instance.health_check_url or f\"http://{instance.host}:{instance.port}/health\",\n                    \"Interval\": \"10s\",\n                    \"Timeout\": \"5s\",\n                },\n            }\n\n            response = await self.client.put(\n                f\"{self.consul_url}/v1/agent/service/register\", json=service_data\n            )\n            response.raise_for_status()\n\n            # Add to local cache\n            if instance.service_name not in self.services:\n                self.services[instance.service_name] = []\n            self.services[instance.service_name].append(instance)\n\n            logger.info(f\"Registered service: {instance.service_name} ({instance.service_id})\")\n\n        except Exception as e:\n            logger.error(f\"Failed to register service {instance.service_id}: {e}\")\n\n    async def discover_services(self, service_name: str) -> List[ServiceInstance]:\n        \"\"\"Discover healthy instances of a service\"\"\"\n        try:\n            response = await self.client.get(\n                f\"{self.consul_url}/v1/health/service/{service_name}\", params={\"passing\": \"true\"}\n            )\n            response.raise_for_status()\n\n            instances = []\n            for entry in response.json():\n                service = entry[\"Service\"]\n                instances.append(\n                    ServiceInstance(\n                        service_id=service[\"ID\"],\n                        service_name=service[\"Service\"],\n                        host=service[\"Address\"],\n                        port=service[\"Port\"],\n                        metadata=service.get(\"Meta\", {}),\n                        status=ServiceStatus.HEALTHY,\n                    )\n                )\n\n            # Update cache\n            self.services[service_name] = instances\n            return instances\n\n        except Exception as e:\n            logger.error(f\"Failed to discover service {service_name}: {e}\")\n            # Return cached instances\n            return self.services.get(service_name, [])\n\n    async def get_service_instance(self, service_name: str) -> Optional[ServiceInstance]:\n        \"\"\"Get a healthy service instance using round-robin load balancing\"\"\"\n        instances = await self.discover_services(service_name)\n        if not instances:\n            return None\n\n        # Simple round-robin (can be enhanced with weighted, least-connections, etc.)\n        return random.choice(instances)\n\n\n# Rate Limiter (Token Bucket)\nclass RateLimiter:\n    \"\"\"Token bucket rate limiter using Redis\"\"\"\n\n    def __init__(self, redis_client: redis.Redis):\n        self.redis = redis_client\n\n    async def check_rate_limit(\n        self, client_id: str, max_requests: int = RATE_LIMIT_REQUESTS, window: int = RATE_LIMIT_WINDOW_SECONDS\n    ) -> bool:\n        \"\"\"Check if request is within rate limit\"\"\"\n        try:\n            key = f\"rate_limit:{client_id}\"\n            current_time = int(time.time())\n            window_start = current_time - window\n\n            # Remove old entries\n            await self.redis.zremrangebyscore(key, 0, window_start)\n\n            # Count requests in current window\n            request_count = await self.redis.zcard(key)\n\n            if request_count >= max_requests:\n                rate_limit_hits.labels(client_id=client_id).inc()\n                return False\n\n            # Add current request\n            await self.redis.zadd(key, {str(uuid.uuid4()): current_time})\n            await self.redis.expire(key, window)\n\n            return True\n\n        except Exception as e:\n            logger.error(f\"Rate limit check failed: {e}\")\n            # Fail open - allow request if rate limiter is down\n            return True\n\n\n# Circuit Breaker\nclass CircuitBreaker:\n    \"\"\"Circuit breaker pattern implementation\"\"\"\n\n    def __init__(self, redis_client: redis.Redis):\n        self.redis = redis_client\n\n    async def get_state(self, service_name: str) -> CircuitBreakerState:\n        \"\"\"Get circuit breaker state for service\"\"\"\n        state_key = f\"circuit_breaker:{service_name}:state\"\n        state = await self.redis.get(state_key)\n        return CircuitBreakerState(state.decode()) if state else CircuitBreakerState.CLOSED\n\n    async def record_success(self, service_name: str):\n        \"\"\"Record successful request\"\"\"\n        failures_key = f\"circuit_breaker:{service_name}:failures\"\n        await self.redis.delete(failures_key)\n\n        # Close circuit if it was open\n        state_key = f\"circuit_breaker:{service_name}:state\"\n        await self.redis.set(state_key, CircuitBreakerState.CLOSED.value)\n\n    async def record_failure(self, service_name: str):\n        \"\"\"Record failed request\"\"\"\n        failures_key = f\"circuit_breaker:{service_name}:failures\"\n        failures = await self.redis.incr(failures_key)\n        await self.redis.expire(failures_key, CIRCUIT_BREAKER_TIMEOUT_SECONDS)\n\n        if failures >= CIRCUIT_BREAKER_THRESHOLD:\n            # Open circuit\n            state_key = f\"circuit_breaker:{service_name}:state\"\n            await self.redis.set(state_key, CircuitBreakerState.OPEN.value, ex=CIRCUIT_BREAKER_TIMEOUT_SECONDS)\n            logger.warning(f\"Circuit breaker OPEN for {service_name} after {failures} failures\")\n\n    async def allow_request(self, service_name: str) -> bool:\n        \"\"\"Check if request should be allowed\"\"\"\n        state = await self.get_state(service_name)\n\n        if state == CircuitBreakerState.CLOSED:\n            return True\n        elif state == CircuitBreakerState.OPEN:\n            # Check if timeout expired - move to half-open\n            state_key = f\"circuit_breaker:{service_name}:state\"\n            ttl = await self.redis.ttl(state_key)\n            if ttl <= 0:\n                await self.redis.set(state_key, CircuitBreakerState.HALF_OPEN.value)\n                return True  # Allow one request to test\n            return False\n        elif state == CircuitBreakerState.HALF_OPEN:\n            return True  # Allow request to test recovery\n\n        return False\n\n\n# API Gateway\nclass APIGateway:\n    \"\"\"API Gateway with routing, auth, rate limiting, and observability\"\"\"\n\n    def __init__(self):\n        self.registry = ServiceRegistry()\n        self.redis_client: Optional[redis.Redis] = None\n        self.rate_limiter: Optional[RateLimiter] = None\n        self.circuit_breaker: Optional[CircuitBreaker] = None\n        self.http_client = httpx.AsyncClient(timeout=30.0)\n        self.routes: Dict[str, RouteConfig] = {}\n        self.tracer = trace.get_tracer(__name__)\n\n    async def initialize(self):\n        \"\"\"Initialize gateway components\"\"\"\n        logger.info(\"ðŸš€ Initializing API Gateway...\")\n\n        # Connect to Redis\n        try:\n            self.redis_client = await redis.from_url(REDIS_URL)\n            await self.redis_client.ping()\n            logger.info(\"âœ… Redis connected\")\n\n            self.rate_limiter = RateLimiter(self.redis_client)\n            self.circuit_breaker = CircuitBreaker(self.redis_client)\n\n        except Exception as e:\n            logger.error(f\"âŒ Redis connection failed: {e}\")\n            raise\n\n        # Load routes configuration\n        self._load_routes()\n\n        # Start health checking\n        asyncio.create_task(self._health_check_loop())\n\n        logger.info(\"âœ… API Gateway initialized\")\n\n    def _load_routes(self):\n        \"\"\"Load route configurations (can be from database/config file)\"\"\"\n        # Example routes - in production, load from config/database\n        self.routes = {\n            \"/api/v1/users\": RouteConfig(\n                path_prefix=\"/api/v1/users\",\n                service_name=\"user-service\",\n                strip_prefix=True,\n                rate_limit=100,\n                auth_required=True,\n            ),\n            \"/api/v1/products\": RouteConfig(\n                path_prefix=\"/api/v1/products\",\n                service_name=\"product-service\",\n                strip_prefix=True,\n                rate_limit=200,\n                auth_required=True,\n            ),\n            \"/api/v1/orders\": RouteConfig(\n                path_prefix=\"/api/v1/orders\",\n                service_name=\"order-service\",\n                strip_prefix=True,\n                rate_limit=50,\n                auth_required=True,\n            ),\n        }\n        logger.info(f\"Loaded {len(self.routes)} route configurations\")\n\n    async def _health_check_loop(self):\n        \"\"\"Background task to check service health\"\"\"\n        while True:\n            try:\n                await asyncio.sleep(30)\n                for service_name in set(r.service_name for r in self.routes.values()):\n                    instances = await self.registry.discover_services(service_name)\n                    healthy_count = sum(1 for i in instances if i.status == ServiceStatus.HEALTHY)\n                    service_health.labels(service=service_name).set(healthy_count)\n\n            except Exception as e:\n                logger.error(f\"Health check error: {e}\")\n\n    def find_route(self, path: str) -> Optional[RouteConfig]:\n        \"\"\"Find matching route for path\"\"\"\n        for prefix, route in self.routes.items():\n            if path.startswith(prefix):\n                return route\n        return None\n\n    async def authenticate(self, token: str) -> JWTToken:\n        \"\"\"Validate JWT token\"\"\"\n        try:\n            payload = jwt.decode(token, JWT_SECRET, algorithms=[JWT_ALGORITHM])\n            return JWTToken(**payload)\n        except jwt.ExpiredSignatureError:\n            raise HTTPException(status_code=401, detail=\"Token expired\")\n        except jwt.InvalidTokenError as e:\n            raise HTTPException(status_code=401, detail=f\"Invalid token: {str(e)}\")\n\n    async def proxy_request(\n        self, request: Request, route: RouteConfig, auth_token: Optional[JWTToken] = None\n    ) -> Response:\n        \"\"\"Proxy request to backend service\"\"\"\n        with self.tracer.start_as_current_span(f\"proxy_{route.service_name}\") as span:\n            span.set_attribute(\"service.name\", route.service_name)\n            span.set_attribute(\"http.method\", request.method)\n            span.set_attribute(\"http.path\", request.url.path)\n\n            # Check circuit breaker\n            if not await self.circuit_breaker.allow_request(route.service_name):\n                span.set_status(Status(StatusCode.ERROR, \"Circuit breaker open\"))\n                raise HTTPException(status_code=503, detail=\"Service temporarily unavailable\")\n\n            # Get service instance\n            instance = await self.registry.get_service_instance(route.service_name)\n            if not instance:\n                span.set_status(Status(StatusCode.ERROR, \"No healthy instances\"))\n                raise HTTPException(status_code=503, detail=\"Service unavailable\")\n\n            # Build target URL\n            path = request.url.path\n            if route.strip_prefix:\n                path = path[len(route.path_prefix) :]\n\n            target_url = f\"http://{instance.host}:{instance.port}{path}\"\n            if request.url.query:\n                target_url += f\"?{request.url.query}\"\n\n            span.set_attribute(\"http.target_url\", target_url)\n\n            # Prepare headers\n            headers = dict(request.headers)\n            if auth_token:\n                headers[\"X-User-ID\"] = auth_token.sub\n                headers[\"X-User-Scopes\"] = \",\".join(auth_token.scopes)\n\n            # Add tracing headers\n            headers[\"X-Request-ID\"] = str(uuid.uuid4())\n            headers[\"X-Trace-ID\"] = format(span.get_span_context().trace_id, \"032x\")\n\n            # Retry logic\n            last_exception = None\n            for attempt in range(route.retry_count):\n                try:\n                    # Make request\n                    response = await self.http_client.request(\n                        method=request.method,\n                        url=target_url,\n                        headers=headers,\n                        content=await request.body(),\n                        timeout=route.timeout_seconds,\n                    )\n\n                    # Record success\n                    await self.circuit_breaker.record_success(route.service_name)\n\n                    span.set_attribute(\"http.status_code\", response.status_code)\n                    span.set_status(Status(StatusCode.OK))\n\n                    return Response(\n                        content=response.content,\n                        status_code=response.status_code,\n                        headers=dict(response.headers),\n                    )\n\n                except Exception as e:\n                    last_exception = e\n                    logger.warning(f\"Request to {route.service_name} failed (attempt {attempt + 1}): {e}\")\n                    if attempt < route.retry_count - 1:\n                        await asyncio.sleep(2 ** attempt)  # Exponential backoff\n\n            # All retries failed\n            await self.circuit_breaker.record_failure(route.service_name)\n            span.set_status(Status(StatusCode.ERROR, str(last_exception)))\n            raise HTTPException(status_code=502, detail=f\"Service error: {str(last_exception)}\")\n\n\n# Initialize gateway\ngateway = APIGateway()\n\n# FastAPI app\napp = FastAPI(\n    title=\"Microservices API Gateway\",\n    description=\"Production-ready API gateway with service mesh capabilities\",\n    version=\"1.0.0\",\n)\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n\n# OpenTelemetry setup\nresource = Resource(attributes={\"service.name\": \"api-gateway\"})\ntrace.set_tracer_provider(TracerProvider(resource=resource))\ntrace.get_tracer_provider().add_span_processor(BatchSpanProcessor(ConsoleSpanExporter()))\n\n\n@app.on_event(\"startup\")\nasync def startup():\n    await gateway.initialize()\n\n\n@app.on_event(\"shutdown\")\nasync def shutdown():\n    if gateway.redis_client:\n        await gateway.redis_client.close()\n    await gateway.http_client.aclose()\n\n\n# Middleware for metrics\n@app.middleware(\"http\")\nasync def metrics_middleware(request: Request, call_next):\n    active_requests.inc()\n    start_time = time.time()\n\n    try:\n        response = await call_next(request)\n        duration = time.time() - start_time\n\n        request_count.labels(method=request.method, path=request.url.path, status=response.status_code).inc()\n        request_duration.labels(method=request.method, path=request.url.path).observe(duration)\n\n        return response\n    finally:\n        active_requests.dec()\n\n\n# Authentication dependency\nasync def get_current_user(authorization: Optional[str] = Header(None)) -> Optional[JWTToken]:\n    \"\"\"Extract and validate JWT from Authorization header\"\"\"\n    if not authorization:\n        return None\n\n    try:\n        scheme, token = authorization.split()\n        if scheme.lower() != \"bearer\":\n            raise HTTPException(status_code=401, detail=\"Invalid authentication scheme\")\n        return await gateway.authenticate(token)\n    except ValueError:\n        raise HTTPException(status_code=401, detail=\"Invalid authorization header\")\n\n\n# API Endpoints\n@app.get(\"/health\")\nasync def health():\n    return {\"status\": \"healthy\", \"timestamp\": datetime.utcnow().isoformat(), \"routes\": len(gateway.routes)}\n\n\n@app.get(\"/metrics\")\nasync def metrics():\n    \"\"\"Prometheus metrics endpoint\"\"\"\n    return Response(content=generate_latest(REGISTRY), media_type=\"text/plain\")\n\n\n@app.post(\"/auth/token\")\nasync def create_token(user_id: str, scopes: List[str] = []):\n    \"\"\"Create JWT token (demo endpoint - use proper auth service in production)\"\"\"\n    expiration = datetime.utcnow() + timedelta(hours=JWT_EXPIRATION_HOURS)\n    payload = {\"sub\": user_id, \"scopes\": scopes, \"exp\": int(expiration.timestamp())}\n    token = jwt.encode(payload, JWT_SECRET, algorithm=JWT_ALGORITHM)\n    return {\"access_token\": token, \"token_type\": \"bearer\", \"expires_at\": expiration.isoformat()}\n\n\n@app.api_route(\"/{path:path}\", methods=[\"GET\", \"POST\", \"PUT\", \"DELETE\", \"PATCH\", \"OPTIONS\"])\nasync def gateway_proxy(request: Request, path: str, auth_token: Optional[JWTToken] = Depends(get_current_user)):\n    \"\"\"Main gateway proxy endpoint\"\"\"\n\n    # Find matching route\n    route = gateway.find_route(f\"/{path}\")\n    if not route:\n        raise HTTPException(status_code=404, detail=\"Route not found\")\n\n    # Check authentication\n    if route.auth_required and not auth_token:\n        raise HTTPException(status_code=401, detail=\"Authentication required\")\n\n    # Rate limiting\n    client_id = auth_token.sub if auth_token else request.client.host\n    rate_limit = route.rate_limit or RATE_LIMIT_REQUESTS\n\n    if not await gateway.rate_limiter.check_rate_limit(client_id, rate_limit, RATE_LIMIT_WINDOW_SECONDS):\n        raise HTTPException(status_code=429, detail=\"Rate limit exceeded\")\n\n    # Proxy request\n    return await gateway.proxy_request(request, route, auth_token)\n\n\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"0.0.0.0\", port=8080)\n",
  "variables": {
    "JWT_SECRET": "your-secret-key-change-in-production",
    "JWT_ALGORITHM": "HS256",
    "JWT_EXPIRATION_HOURS": "24",
    "REDIS_URL": "redis://localhost:6379",
    "CONSUL_HOST": "localhost",
    "CONSUL_PORT": "8500",
    "RATE_LIMIT_REQUESTS": "100",
    "RATE_LIMIT_WINDOW_SECONDS": "60",
    "CIRCUIT_BREAKER_THRESHOLD": "5",
    "CIRCUIT_BREAKER_TIMEOUT_SECONDS": "60"
  },
  "dependencies": [
    "fastapi>=0.109.0",
    "uvicorn[standard]>=0.27.0",
    "pydantic>=2.5.0",
    "redis[hiredis]>=5.0.0",
    "httpx>=0.25.0",
    "pyjwt>=2.8.0",
    "opentelemetry-api>=1.21.0",
    "opentelemetry-sdk>=1.21.0",
    "opentelemetry-exporter-prometheus>=0.42b0",
    "prometheus-client>=0.19.0",
    "python-consul>=1.1.0"
  ],
  "workflow_context": {
    "typical_use_cases": [
      "API Gateway with Rate Limiting and Auth",
      "Service Mesh with Observability",
      "Microservices Platform Foundation",
      "Distributed System Traffic Management",
      "Multi-Service API Aggregation"
    ],
    "team_composition": [
      "solution_architect",
      "backend_developer",
      "devops_engineer",
      "security_specialist"
    ],
    "estimated_time_minutes": 480,
    "prerequisites": [
      "Redis server running",
      "Consul agent running (or replace with etcd/Eureka)",
      "Backend microservices with /health endpoints",
      "Python 3.9+ with pip",
      "Understanding of JWT and API security"
    ],
    "related_templates": [
      "websocket-real-time-server-v1",
      "iot-device-management-platform-v1"
    ],
    "deployment_notes": [
      "Generate strong JWT_SECRET in production (32+ chars)",
      "Configure Consul cluster for HA service discovery",
      "Set up Prometheus to scrape /metrics endpoint",
      "Use Redis cluster for high availability",
      "Configure CORS origins for your domains",
      "Implement API versioning strategy (path-based, header-based)",
      "Add custom middleware for request transformation",
      "Set up centralized logging with correlation IDs",
      "Configure circuit breaker thresholds based on SLA",
      "Implement rate limiting per API key instead of IP for better tracking",
      "Deploy behind load balancer (Nginx, HAProxy) for redundancy",
      "Use TLS/SSL for all service-to-service communication"
    ]
  }
}
