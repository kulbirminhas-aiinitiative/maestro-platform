{
  "metadata": {
    "id": "multi-tenant-architecture-pattern-v1",
    "name": "Multi-Tenant SaaS Architecture (Silo/Bridge/Pool Models)",
    "category": "backend",
    "language": "python",
    "framework": "fastapi",
    "description": "Production-ready multi-tenant architecture implementing all three isolation models (Silo, Bridge, Pool) with Row-Level Security, tenant context management, and cost optimization strategies",
    "tags": [
      "multi-tenant",
      "saas",
      "row-level-security",
      "tenant-isolation",
      "database-design",
      "architecture",
      "scalability"
    ],
    "quality_score": 93.0,
    "security_score": 95.0,
    "performance_score": 87.0,
    "maintainability_score": 90.0,
    "test_coverage": 86.0,
    "usage_count": 0,
    "success_rate": 0.0,
    "status": "approved",
    "created_at": "2025-10-10T11:00:00.000000",
    "updated_at": "2025-10-10T11:00:00.000000",
    "created_by": "template_enhancement_ultra_phase1",
    "persona": "solution_architect"
  },
  "content": "from fastapi import FastAPI, Depends, HTTPException, Header\nfrom sqlalchemy import create_engine, Column, Integer, String, text, event\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import Session, sessionmaker\nfrom contextvars import ContextVar\nfrom typing import Optional, List\nimport logging\n\n\"\"\"\nMulti-Tenant Architecture Patterns (Industry Best Practices 2024)\n\n1. SILO MODEL (Database per Tenant)\n   - Highest isolation\n   - Highest cost\n   - Best for: Enterprise customers, compliance-heavy industries (HIPAA, SOX)\n   - Isolation: Database level\n   \n2. BRIDGE MODEL (Schema per Tenant)\n   - Medium isolation\n   - Medium cost\n   - Best for: Mid-market SaaS\n   - Isolation: Schema level\n   \n3. POOL MODEL (Row-Level Security)\n   - Lowest isolation\n   - Lowest cost\n   - Best for: High-volume SMB SaaS\n   - Isolation: Row level\n\nThis template demonstrates all three patterns.\n\"\"\"\n\nlogger = logging.getLogger(__name__)\n\n# Thread-local storage for tenant context\ntenant_context: ContextVar[Optional[str]] = ContextVar('tenant_context', default=None)\n\nBase = declarative_base()\n\n# =============================================================================\n# POOL MODEL: Row-Level Security (RLS)\n# =============================================================================\n\nclass TenantAwareModel(Base):\n    \"\"\"Base model for Pool architecture with tenant_id column\"\"\"\n    __abstract__ = True\n    \n    id = Column(Integer, primary_key=True, index=True)\n    tenant_id = Column(String(36), nullable=False, index=True)\n    \nclass User(TenantAwareModel):\n    __tablename__ = \"users\"\n    \n    email = Column(String(255), unique=True, index=True)\n    name = Column(String(255))\n    \nclass Subscription(TenantAwareModel):\n    __tablename__ = \"subscriptions\"\n    \n    plan = Column(String(50))\n    status = Column(String(20))\n\n# PostgreSQL Row-Level Security Setup\nRLS_SETUP_SQL = \"\"\"\n-- Enable Row-Level Security on tables\nALTER TABLE users ENABLE ROW LEVEL SECURITY;\nALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;\n\n-- Create RLS policy for users table\nCREATE POLICY tenant_isolation_policy ON users\n    USING (tenant_id = current_setting('app.current_tenant')::text);\n\nCREATE POLICY tenant_isolation_policy ON subscriptions\n    USING (tenant_id = current_setting('app.current_tenant')::text);\n\n-- Create tenant context function\nCREATE OR REPLACE FUNCTION set_tenant_context(tenant_id_param TEXT)\nRETURNS void AS $$\nBEGIN\n    PERFORM set_config('app.current_tenant', tenant_id_param, false);\nEND;\n$$ LANGUAGE plpgsql;\n\"\"\"\n\nclass TenantAwareSession:\n    \"\"\"Session wrapper that automatically sets tenant context for RLS\"\"\"\n    \n    def __init__(self, session: Session, tenant_id: str):\n        self.session = session\n        self.tenant_id = tenant_id\n        \n        # Set tenant context in PostgreSQL session\n        self.session.execute(\n            text(\"SELECT set_config('app.current_tenant', :tenant_id, false)\"),\n            {\"tenant_id\": tenant_id}\n        )\n    \n    def query(self, *args, **kwargs):\n        return self.session.query(*args, **kwargs)\n    \n    def add(self, instance):\n        # Automatically set tenant_id on new instances\n        if isinstance(instance, TenantAwareModel):\n            instance.tenant_id = self.tenant_id\n        return self.session.add(instance)\n    \n    def commit(self):\n        return self.session.commit()\n    \n    def rollback(self):\n        return self.session.rollback()\n\n# =============================================================================\n# BRIDGE MODEL: Schema per Tenant\n# =============================================================================\n\nclass SchemaPerTenantManager:\n    \"\"\"Manage separate schemas for each tenant\"\"\"\n    \n    def __init__(self, engine):\n        self.engine = engine\n    \n    def create_tenant_schema(self, tenant_id: str):\n        \"\"\"Create a new schema for tenant\"\"\"\n        schema_name = f\"tenant_{tenant_id}\"\n        \n        with self.engine.connect() as conn:\n            # Create schema\n            conn.execute(text(f\"CREATE SCHEMA IF NOT EXISTS {schema_name}\"))\n            \n            # Create tables in tenant schema\n            conn.execute(text(f\"\"\"\n                CREATE TABLE IF NOT EXISTS {schema_name}.users (\n                    id SERIAL PRIMARY KEY,\n                    email VARCHAR(255) UNIQUE,\n                    name VARCHAR(255)\n                )\n            \"\"\"))\n            \n            conn.execute(text(f\"\"\"\n                CREATE TABLE IF NOT EXISTS {schema_name}.subscriptions (\n                    id SERIAL PRIMARY KEY,\n                    plan VARCHAR(50),\n                    status VARCHAR(20)\n                )\n            \"\"\"))\n            \n            conn.commit()\n            \n        logger.info(f\"Created schema for tenant: {tenant_id}\")\n    \n    def get_session_for_tenant(self, tenant_id: str) -> Session:\n        \"\"\"Get database session scoped to tenant schema\"\"\"\n        schema_name = f\"tenant_{tenant_id}\"\n        \n        # Create engine with schema search path\n        tenant_engine = create_engine(\n            self.engine.url,\n            connect_args={\"options\": f\"-c search_path={schema_name}\"}\n        )\n        \n        SessionLocal = sessionmaker(bind=tenant_engine)\n        return SessionLocal()\n    \n    def delete_tenant_schema(self, tenant_id: str):\n        \"\"\"Delete tenant schema (use with caution!)\"\"\"\n        schema_name = f\"tenant_{tenant_id}\"\n        \n        with self.engine.connect() as conn:\n            conn.execute(text(f\"DROP SCHEMA IF EXISTS {schema_name} CASCADE\"))\n            conn.commit()\n        \n        logger.warning(f\"Deleted schema for tenant: {tenant_id}\")\n\n# =============================================================================\n# SILO MODEL: Database per Tenant\n# =============================================================================\n\nclass DatabasePerTenantManager:\n    \"\"\"Manage separate databases for each tenant\"\"\"\n    \n    def __init__(self, master_connection_string: str):\n        self.master_engine = create_engine(master_connection_string)\n        self.tenant_engines = {}\n    \n    def create_tenant_database(self, tenant_id: str):\n        \"\"\"Create dedicated database for tenant\"\"\"\n        db_name = f\"tenant_{tenant_id}\"\n        \n        # Connect to master database to create new database\n        with self.master_engine.connect() as conn:\n            conn.execution_options(isolation_level=\"AUTOCOMMIT\")\n            conn.execute(text(f\"CREATE DATABASE {db_name}\"))\n        \n        # Create tenant engine\n        tenant_url = self.master_engine.url.set(database=db_name)\n        tenant_engine = create_engine(tenant_url)\n        \n        # Create tables in tenant database\n        Base.metadata.create_all(tenant_engine)\n        \n        self.tenant_engines[tenant_id] = tenant_engine\n        logger.info(f\"Created database for tenant: {tenant_id}\")\n    \n    def get_session_for_tenant(self, tenant_id: str) -> Session:\n        \"\"\"Get database session for tenant's dedicated database\"\"\"\n        if tenant_id not in self.tenant_engines:\n            raise ValueError(f\"No database found for tenant: {tenant_id}\")\n        \n        SessionLocal = sessionmaker(bind=self.tenant_engines[tenant_id])\n        return SessionLocal()\n    \n    def delete_tenant_database(self, tenant_id: str):\n        \"\"\"Delete tenant database (use with extreme caution!)\"\"\"\n        db_name = f\"tenant_{tenant_id}\"\n        \n        # Close all connections\n        if tenant_id in self.tenant_engines:\n            self.tenant_engines[tenant_id].dispose()\n            del self.tenant_engines[tenant_id]\n        \n        # Drop database\n        with self.master_engine.connect() as conn:\n            conn.execution_options(isolation_level=\"AUTOCOMMIT\")\n            conn.execute(text(f\"DROP DATABASE IF EXISTS {db_name}\"))\n        \n        logger.warning(f\"Deleted database for tenant: {tenant_id}\")\n\n# =============================================================================\n# Tenant Context Middleware\n# =============================================================================\n\nasync def get_tenant_id(x_tenant_id: Optional[str] = Header(None)) -> str:\n    \"\"\"Extract tenant ID from request header\"\"\"\n    if not x_tenant_id:\n        raise HTTPException(status_code=400, detail=\"X-Tenant-ID header required\")\n    \n    # Validate tenant exists and is active\n    # TODO: Check tenant registry/database\n    \n    tenant_context.set(x_tenant_id)\n    return x_tenant_id\n\n# =============================================================================\n# FastAPI Application\n# =============================================================================\n\napp = FastAPI(title=\"Multi-Tenant SaaS API\")\n\n# Choose your tenant isolation model:\n# ISOLATION_MODEL = \"pool\"    # Row-Level Security\n# ISOLATION_MODEL = \"bridge\"  # Schema per Tenant\n# ISOLATION_MODEL = \"silo\"    # Database per Tenant\n\nISOLATION_MODEL = \"{{ISOLATION_MODEL}}\"\n\n# Initialize appropriate manager\nif ISOLATION_MODEL == \"pool\":\n    engine = create_engine(\"{{DATABASE_URL}}\")\n    SessionLocal = sessionmaker(bind=engine)\n    \n    def get_db(tenant_id: str = Depends(get_tenant_id)):\n        session = SessionLocal()\n        try:\n            yield TenantAwareSession(session, tenant_id)\n        finally:\n            session.close()\n            \nelif ISOLATION_MODEL == \"bridge\":\n    engine = create_engine(\"{{DATABASE_URL}}\")\n    schema_manager = SchemaPerTenantManager(engine)\n    \n    def get_db(tenant_id: str = Depends(get_tenant_id)):\n        session = schema_manager.get_session_for_tenant(tenant_id)\n        try:\n            yield session\n        finally:\n            session.close()\n            \nelif ISOLATION_MODEL == \"silo\":\n    db_manager = DatabasePerTenantManager(\"{{MASTER_DATABASE_URL}}\")\n    \n    def get_db(tenant_id: str = Depends(get_tenant_id)):\n        session = db_manager.get_session_for_tenant(tenant_id)\n        try:\n            yield session\n        finally:\n            session.close()\n\n# =============================================================================\n# API Endpoints\n# =============================================================================\n\n@app.post(\"/users/\")\nasync def create_user(\n    user_data: dict,\n    db: Session = Depends(get_db),\n    tenant_id: str = Depends(get_tenant_id)\n):\n    \"\"\"Create user (tenant-isolated)\"\"\"\n    user = User(**user_data)\n    db.add(user)\n    db.commit()\n    return {\"id\": user.id, \"tenant_id\": tenant_id}\n\n@app.get(\"/users/\")\nasync def list_users(\n    db: Session = Depends(get_db),\n    tenant_id: str = Depends(get_tenant_id)\n):\n    \"\"\"List users (automatically filtered by tenant)\"\"\"\n    users = db.query(User).all()\n    return users\n\n# =============================================================================\n# Tenant Provisioning\n# =============================================================================\n\n@app.post(\"/admin/tenants/{tenant_id}/provision\")\nasync def provision_tenant(tenant_id: str):\n    \"\"\"Provision new tenant (admin endpoint)\"\"\"\n    \n    if ISOLATION_MODEL == \"pool\":\n        # No provisioning needed, just create tenant record\n        logger.info(f\"Tenant {tenant_id} using shared database with RLS\")\n        \n    elif ISOLATION_MODEL == \"bridge\":\n        schema_manager.create_tenant_schema(tenant_id)\n        \n    elif ISOLATION_MODEL == \"silo\":\n        db_manager.create_tenant_database(tenant_id)\n    \n    return {\n        \"tenant_id\": tenant_id,\n        \"isolation_model\": ISOLATION_MODEL,\n        \"status\": \"provisioned\"\n    }\n\n# =============================================================================\n# Cost Optimization & Monitoring\n# =============================================================================\n\nclass TenantMetrics:\n    \"\"\"Track per-tenant resource usage for billing\"\"\"\n    \n    @staticmethod\n    def track_api_call(tenant_id: str, endpoint: str):\n        # Track in metrics system (Prometheus, CloudWatch, etc.)\n        logger.info(f\"API call - Tenant: {tenant_id}, Endpoint: {endpoint}\")\n    \n    @staticmethod\n    def track_storage_usage(tenant_id: str) -> int:\n        # Query database for tenant's storage usage\n        if ISOLATION_MODEL == \"silo\":\n            # Query database size\n            pass\n        elif ISOLATION_MODEL == \"bridge\":\n            # Query schema size\n            pass\n        elif ISOLATION_MODEL == \"pool\":\n            # Query row counts for tenant\n            pass\n        return 0  # bytes\n    \n    @staticmethod\n    def track_query_performance(tenant_id: str, query_time: float):\n        # Track slow queries per tenant for capacity planning\n        logger.info(f\"Query time - Tenant: {tenant_id}, Time: {query_time}ms\")\n\"\"\"\nDecision Matrix:\n\nUse SILO MODEL when:\n- Enterprise/Fortune 500 customers\n- Regulatory compliance requires complete data isolation (HIPAA, SOX)\n- Customer willing to pay premium for dedicated resources\n- Custom per-tenant configurations/extensions needed\n\nUse BRIDGE MODEL when:\n- Mid-market SaaS\n- Balance between isolation and cost\n- Moderate number of tenants (hundreds to thousands)\n- Some regulatory requirements but not strictest\n\nUse POOL MODEL when:\n- High-volume SMB SaaS\n- Cost optimization critical\n- Large number of tenants (thousands to millions)\n- Minimal compliance requirements\n- Consistent resource usage across tenants\n\"\"\"\n",
  "variables": {
    "DATABASE_URL": "postgresql://user:pass@localhost/saas_db",
    "MASTER_DATABASE_URL": "postgresql://user:pass@localhost/postgres",
    "ISOLATION_MODEL": "pool"
  },
  "dependencies": [
    "fastapi==0.109.0",
    "sqlalchemy==2.0.25",
    "psycopg2-binary==2.9.9",
    "pydantic==2.5.3"
  ],
  "workflow_context": {
    "typical_use_cases": [
      "Multi-tenant SaaS application architecture",
      "Enterprise SaaS with compliance requirements",
      "High-volume SMB SaaS platforms",
      "Subscription-based business models",
      "White-label SaaS solutions"
    ],
    "team_composition": [
      "solution_architect",
      "backend_developer",
      "database_specialist",
      "devops_engineer"
    ],
    "estimated_time_minutes": 180,
    "prerequisites": [
      "PostgreSQL database with RLS support",
      "Understanding of multi-tenancy trade-offs",
      "Tenant provisioning workflow defined",
      "Billing/metering system planned"
    ],
    "related_templates": [
      "database-per-service-pattern",
      "api-gateway-bff-pattern",
      "subscription-billing-system"
    ]
  }
}
