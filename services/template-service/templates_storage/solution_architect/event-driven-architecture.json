{
  "metadata": {
    "id": "event-driven-architecture-v1",
    "name": "Event-Driven Architecture with Event Sourcing & CQRS",
    "category": "backend",
    "language": "typescript",
    "framework": "nodejs",
    "description": "Production-ready event-driven architecture implementing event sourcing, CQRS pattern, event store, and message broker integration for distributed systems",
    "tags": [
      "event-driven",
      "event-sourcing",
      "cqrs",
      "microservices",
      "message-broker",
      "kafka",
      "distributed-systems"
    ],
    "quality_score": 91.0,
    "security_score": 83.0,
    "performance_score": 88.0,
    "maintainability_score": 89.0,
    "test_coverage": 85.0,
    "usage_count": 0,
    "success_rate": 0.0,
    "status": "approved",
    "created_at": "2025-10-10T11:00:00.000000",
    "updated_at": "2025-10-10T11:00:00.000000",
    "created_by": "template_enhancement_ultra_phase1",
    "persona": "solution_architect"
  },
  "content": "import { Kafka, Producer, Consumer, EachMessagePayload } from 'kafkajs';\nimport { EventEmitter } from 'events';\nimport { v4 as uuid } from 'uuid';\n\n/**\n * Event-Driven Architecture Pattern\n * \n * Components:\n * 1. Event Store: Append-only log of all domain events\n * 2. Event Bus: Message broker for event distribution (Kafka/RabbitMQ/SNS)\n * 3. Event Handlers: Subscribe to and process events\n * 4. CQRS: Separate read and write models\n * 5. Event Sourcing: Rebuild state from events\n * \n * Benefits:\n * - Scalability: Independent scaling of components\n * - Resilience: Decoupled services\n * - Audit Trail: Complete history of changes\n * - Time Travel: Replay events to any point in time\n * - Event-driven workflows: Saga orchestration\n */\n\n// =============================================================================\n// Event Types & Interfaces\n// =============================================================================\n\ninterface DomainEvent {\n  eventId: string;\n  eventType: string;\n  aggregateId: string;\n  aggregateType: string;\n  version: number;\n  timestamp: Date;\n  userId?: string;\n  metadata?: Record<string, any>;\n  payload: any;\n}\n\ninterface EventEnvelope {\n  event: DomainEvent;\n  partition?: number;\n  headers?: Record<string, string>;\n}\n\n// Domain Event Examples\nclass OrderCreatedEvent implements DomainEvent {\n  eventId: string = uuid();\n  eventType: string = 'OrderCreated';\n  aggregateType: string = 'Order';\n  timestamp: Date = new Date();\n  \n  constructor(\n    public aggregateId: string,\n    public version: number,\n    public payload: {\n      customerId: string;\n      items: Array<{productId: string; quantity: number; price: number}>;\n      totalAmount: number;\n    },\n    public userId?: string,\n    public metadata?: Record<string, any>\n  ) {}\n}\n\nclass OrderShippedEvent implements DomainEvent {\n  eventId: string = uuid();\n  eventType: string = 'OrderShipped';\n  aggregateType: string = 'Order';\n  timestamp: Date = new Date();\n  \n  constructor(\n    public aggregateId: string,\n    public version: number,\n    public payload: {\n      trackingNumber: string;\n      carrier: string;\n      estimatedDelivery: Date;\n    },\n    public userId?: string,\n    public metadata?: Record<string, any>\n  ) {}\n}\n\n// =============================================================================\n// Event Store (Append-Only Log)\n// =============================================================================\n\nclass EventStore {\n  private events: Map<string, DomainEvent[]> = new Map();\n  \n  /**\n   * Append event to store (write-only, immutable)\n   */\n  async append(event: DomainEvent): Promise<void> {\n    const streamId = `${event.aggregateType}-${event.aggregateId}`;\n    \n    if (!this.events.has(streamId)) {\n      this.events.set(streamId, []);\n    }\n    \n    const stream = this.events.get(streamId)!;\n    \n    // Optimistic concurrency check\n    if (stream.length > 0 && stream[stream.length - 1].version >= event.version) {\n      throw new ConcurrencyError(\n        `Concurrent modification detected for ${streamId}. Expected version ${stream.length + 1}, got ${event.version}`\n      );\n    }\n    \n    stream.push(event);\n    \n    console.log(`Event stored: ${event.eventType} for ${streamId} (v${event.version})`);\n  }\n  \n  /**\n   * Get all events for an aggregate (event stream)\n   */\n  async getEvents(aggregateType: string, aggregateId: string, fromVersion: number = 0): Promise<DomainEvent[]> {\n    const streamId = `${aggregateType}-${aggregateId}`;\n    const stream = this.events.get(streamId) || [];\n    \n    return stream.filter(event => event.version >= fromVersion);\n  }\n  \n  /**\n   * Get events by type (for projections)\n   */\n  async getEventsByType(eventType: string, since?: Date): Promise<DomainEvent[]> {\n    const allEvents: DomainEvent[] = [];\n    \n    for (const stream of this.events.values()) {\n      for (const event of stream) {\n        if (event.eventType === eventType) {\n          if (!since || event.timestamp >= since) {\n            allEvents.push(event);\n          }\n        }\n      }\n    }\n    \n    return allEvents.sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());\n  }\n}\n\n// =============================================================================\n// Event Bus (Kafka Integration)\n// =============================================================================\n\nclass EventBus {\n  private kafka: Kafka;\n  private producer: Producer;\n  private consumers: Map<string, Consumer> = new Map();\n  private eventEmitter: EventEmitter = new EventEmitter();\n  \n  constructor(brokers: string[]) {\n    this.kafka = new Kafka({\n      clientId: '{{SERVICE_NAME}}',\n      brokers: brokers,\n      retry: {\n        initialRetryTime: 100,\n        retries: 8\n      }\n    });\n    \n    this.producer = this.kafka.producer({\n      allowAutoTopicCreation: true,\n      transactionalId: '{{SERVICE_NAME}}-producer',\n      idempotent: true\n    });\n  }\n  \n  async connect(): Promise<void> {\n    await this.producer.connect();\n    console.log('Event Bus connected');\n  }\n  \n  /**\n   * Publish event to event bus\n   */\n  async publish(event: DomainEvent): Promise<void> {\n    const topic = `${event.aggregateType}.${event.eventType}`;\n    \n    await this.producer.send({\n      topic,\n      messages: [\n        {\n          key: event.aggregateId,\n          value: JSON.stringify(event),\n          headers: {\n            'event-type': event.eventType,\n            'event-id': event.eventId,\n            'timestamp': event.timestamp.toISOString()\n          },\n          partition: this.getPartition(event.aggregateId)\n        }\n      ]\n    });\n    \n    // Also emit locally for synchronous handlers\n    this.eventEmitter.emit(event.eventType, event);\n    \n    console.log(`Event published: ${event.eventType} to ${topic}`);\n  }\n  \n  /**\n   * Subscribe to events\n   */\n  async subscribe(\n    eventType: string,\n    groupId: string,\n    handler: (event: DomainEvent) => Promise<void>\n  ): Promise<void> {\n    const topic = `*.${eventType}`; // Subscribe to all aggregates emitting this event\n    \n    if (!this.consumers.has(groupId)) {\n      const consumer = this.kafka.consumer({ groupId });\n      await consumer.connect();\n      await consumer.subscribe({ topic, fromBeginning: false });\n      \n      await consumer.run({\n        eachMessage: async ({ topic, partition, message }: EachMessagePayload) => {\n          try {\n            const event: DomainEvent = JSON.parse(message.value!.toString());\n            await handler(event);\n          } catch (error) {\n            console.error(`Error handling event: ${error}`);\n            // Implement dead-letter queue\n          }\n        }\n      });\n      \n      this.consumers.set(groupId, consumer);\n    }\n    \n    // Also register local handler\n    this.eventEmitter.on(eventType, handler);\n  }\n  \n  private getPartition(key: string): number {\n    // Consistent hashing for partition assignment\n    let hash = 0;\n    for (let i = 0; i < key.length; i++) {\n      hash = ((hash << 5) - hash) + key.charCodeAt(i);\n      hash = hash & hash;\n    }\n    return Math.abs(hash) % {{NUM_PARTITIONS}};\n  }\n  \n  async disconnect(): Promise<void> {\n    await this.producer.disconnect();\n    for (const consumer of this.consumers.values()) {\n      await consumer.disconnect();\n    }\n  }\n}\n\n// =============================================================================\n// Aggregate Root (Event Sourcing)\n// =============================================================================\n\nabstract class AggregateRoot {\n  protected version: number = 0;\n  protected uncommittedEvents: DomainEvent[] = [];\n  \n  constructor(public id: string) {}\n  \n  /**\n   * Apply event to aggregate (replay or new)\n   */\n  protected applyEvent(event: DomainEvent, isNew: boolean = true): void {\n    // Use double dispatch to call specific apply method\n    const methodName = `apply${event.eventType}`;\n    if (typeof (this as any)[methodName] === 'function') {\n      (this as any)[methodName](event.payload);\n    }\n    \n    this.version = event.version;\n    \n    if (isNew) {\n      this.uncommittedEvents.push(event);\n    }\n  }\n  \n  /**\n   * Load aggregate from event history\n   */\n  loadFromHistory(events: DomainEvent[]): void {\n    for (const event of events) {\n      this.applyEvent(event, false);\n    }\n  }\n  \n  getUncommittedEvents(): DomainEvent[] {\n    return this.uncommittedEvents;\n  }\n  \n  markEventsAsCommitted(): void {\n    this.uncommittedEvents = [];\n  }\n}\n\n// Example Aggregate\nclass Order extends AggregateRoot {\n  customerId?: string;\n  items: Array<{productId: string; quantity: number; price: number}> = [];\n  totalAmount: number = 0;\n  status: string = 'PENDING';\n  trackingNumber?: string;\n  \n  /**\n   * Command: Create Order\n   */\n  create(customerId: string, items: typeof this.items): void {\n    const event = new OrderCreatedEvent(\n      this.id,\n      this.version + 1,\n      { customerId, items, totalAmount: this.calculateTotal(items) }\n    );\n    \n    this.applyEvent(event);\n  }\n  \n  /**\n   * Event Handler: OrderCreated\n   */\n  private applyOrderCreated(payload: any): void {\n    this.customerId = payload.customerId;\n    this.items = payload.items;\n    this.totalAmount = payload.totalAmount;\n    this.status = 'CREATED';\n  }\n  \n  /**\n   * Command: Ship Order\n   */\n  ship(trackingNumber: string, carrier: string, estimatedDelivery: Date): void {\n    if (this.status !== 'CREATED') {\n      throw new Error(`Cannot ship order in status: ${this.status}`);\n    }\n    \n    const event = new OrderShippedEvent(\n      this.id,\n      this.version + 1,\n      { trackingNumber, carrier, estimatedDelivery }\n    );\n    \n    this.applyEvent(event);\n  }\n  \n  /**\n   * Event Handler: OrderShipped\n   */\n  private applyOrderShipped(payload: any): void {\n    this.trackingNumber = payload.trackingNumber;\n    this.status = 'SHIPPED';\n  }\n  \n  private calculateTotal(items: typeof this.items): number {\n    return items.reduce((sum, item) => sum + (item.price * item.quantity), 0);\n  }\n}\n\n// =============================================================================\n// Repository (Persist & Retrieve Aggregates)\n// =============================================================================\n\nclass OrderRepository {\n  constructor(\n    private eventStore: EventStore,\n    private eventBus: EventBus\n  ) {}\n  \n  /**\n   * Save aggregate (persist events)\n   */\n  async save(order: Order): Promise<void> {\n    const events = order.getUncommittedEvents();\n    \n    for (const event of events) {\n      await this.eventStore.append(event);\n      await this.eventBus.publish(event);\n    }\n    \n    order.markEventsAsCommitted();\n  }\n  \n  /**\n   * Load aggregate (replay events)\n   */\n  async getById(orderId: string): Promise<Order> {\n    const events = await this.eventStore.getEvents('Order', orderId);\n    \n    if (events.length === 0) {\n      throw new Error(`Order not found: ${orderId}`);\n    }\n    \n    const order = new Order(orderId);\n    order.loadFromHistory(events);\n    \n    return order;\n  }\n}\n\n// =============================================================================\n// Read Model (CQRS - Query Side)\n// =============================================================================\n\ninterface OrderReadModel {\n  orderId: string;\n  customerId: string;\n  totalAmount: number;\n  status: string;\n  createdAt: Date;\n  shippedAt?: Date;\n  trackingNumber?: string;\n}\n\nclass OrderReadModelProjection {\n  private readModels: Map<string, OrderReadModel> = new Map();\n  \n  constructor(eventBus: EventBus) {\n    // Subscribe to events and update read models\n    eventBus.subscribe('OrderCreated', 'order-read-model', this.handleOrderCreated.bind(this));\n    eventBus.subscribe('OrderShipped', 'order-read-model', this.handleOrderShipped.bind(this));\n  }\n  \n  private async handleOrderCreated(event: DomainEvent): Promise<void> {\n    const orderCreated = event as OrderCreatedEvent;\n    \n    this.readModels.set(orderCreated.aggregateId, {\n      orderId: orderCreated.aggregateId,\n      customerId: orderCreated.payload.customerId,\n      totalAmount: orderCreated.payload.totalAmount,\n      status: 'CREATED',\n      createdAt: orderCreated.timestamp\n    });\n  }\n  \n  private async handleOrderShipped(event: DomainEvent): Promise<void> {\n    const orderShipped = event as OrderShippedEvent;\n    const readModel = this.readModels.get(orderShipped.aggregateId);\n    \n    if (readModel) {\n      readModel.status = 'SHIPPED';\n      readModel.shippedAt = orderShipped.timestamp;\n      readModel.trackingNumber = orderShipped.payload.trackingNumber;\n    }\n  }\n  \n  /**\n   * Query methods (optimized for reads)\n   */\n  getOrderById(orderId: string): OrderReadModel | undefined {\n    return this.readModels.get(orderId);\n  }\n  \n  getOrdersByCustomer(customerId: string): OrderReadModel[] {\n    return Array.from(this.readModels.values())\n      .filter(order => order.customerId === customerId);\n  }\n  \n  getOrdersByStatus(status: string): OrderReadModel[] {\n    return Array.from(this.readModels.values())\n      .filter(order => order.status === status);\n  }\n}\n\n// =============================================================================\n// Usage Example\n// =============================================================================\n\nasync function main() {\n  const eventStore = new EventStore();\n  const eventBus = new EventBus(['{{KAFKA_BROKER}}']);\n  await eventBus.connect();\n  \n  const orderRepository = new OrderRepository(eventStore, eventBus);\n  const orderReadModel = new OrderReadModelProjection(eventBus);\n  \n  // WRITE SIDE (Commands)\n  const order = new Order(uuid());\n  order.create('customer-123', [\n    { productId: 'prod-1', quantity: 2, price: 29.99 },\n    { productId: 'prod-2', quantity: 1, price: 49.99 }\n  ]);\n  \n  await orderRepository.save(order);\n  \n  // Later: ship the order\n  order.ship('TRACK123', 'UPS', new Date('2025-10-15'));\n  await orderRepository.save(order);\n  \n  // READ SIDE (Queries)\n  const customerOrders = orderReadModel.getOrdersByCustomer('customer-123');\n  console.log('Customer orders:', customerOrders);\n  \n  await eventBus.disconnect();\n}\n\nclass ConcurrencyError extends Error {}\n\nexport { EventBus, EventStore, OrderRepository, OrderReadModelProjection, Order };\n",
  "variables": {
    "SERVICE_NAME": "order-service",
    "KAFKA_BROKER": "localhost:9092",
    "NUM_PARTITIONS": "3"
  },
  "dependencies": [
    "kafkajs@^2.2.4",
    "uuid@^9.0.1",
    "@types/uuid@^9.0.7"
  ],
  "workflow_context": {
    "typical_use_cases": [
      "Event-driven microservices architecture",
      "CQRS pattern implementation",
      "Audit trail requirements",
      "Event sourcing for domain models",
      "Saga orchestration workflows"
    ],
    "team_composition": [
      "solution_architect",
      "backend_developer",
      "devops_engineer"
    ],
    "estimated_time_minutes": 240,
    "prerequisites": [
      "Kafka/RabbitMQ message broker setup",
      "Understanding of CQRS and Event Sourcing",
      "Domain model defined",
      "Event schema registry configured"
    ],
    "related_templates": [
      "saga-orchestration-pattern",
      "circuit-breaker-pattern",
      "multi-tenant-architecture-pattern"
    ]
  }
}
