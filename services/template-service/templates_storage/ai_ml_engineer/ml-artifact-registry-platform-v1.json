{
  "template_id": "ml-artifact-registry-platform-v1",
  "name": "ML Artifact Registry Platform",
  "version": "1.0.0",
  "description": "Meta-learning platform for managing reusable ML artifacts with impact tracking and smart recommendations.",
  "persona": "ai_ml_engineer",
  "category": "ml_platform",
  "complexity": "advanced",
  "tags": [
    "ml-ops",
    "artifact-registry",
    "meta-learning",
    "fastapi",
    "sqlalchemy",
    "python"
  ],
  "use_cases": [
    "ML component reuse",
    "Feature pipeline sharing",
    "Model template library"
  ],
  "quality_score": 94,
  "security_score": 92,
  "performance_score": 91,
  "maintainability_score": 93,
  "extracted_from": "Conductor ML Platform (Production)",
  "implementation": {
    "artifact_registry.py": "#!/usr/bin/env python3\n\"\"\"\nArtifact Registry Service - The \"Music Library\"\n\nManages reusable ML artifacts (feature pipelines, model templates, schemas, notebooks).\nTracks usage and calculates impact scores to identify valuable components.\n\"\"\"\n\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy import select, and_, or_, func, Text\nfrom typing import List, Optional, Dict, Any\nfrom datetime import datetime\nimport hashlib\n\nfrom maestro_ml.models.database import Artifact, ArtifactUsage, ArtifactCreate, ArtifactResponse\n\n\nclass ArtifactRegistry:\n    \"\"\"Artifact registry service for managing reusable ML components\"\"\"\n\n    async def create_artifact(\n        self,\n        session: AsyncSession,\n        artifact_data: ArtifactCreate\n    ) -> Artifact:\n        \"\"\"Register a new artifact in the library\"\"\"\n\n        # Calculate content hash\n        content_hash = self._calculate_hash(artifact_data.storage_path)\n\n        artifact = Artifact(\n            name=artifact_data.name,\n            type=artifact_data.type,\n            version=artifact_data.version,\n            created_by=artifact_data.created_by,\n            tags=artifact_data.tags,\n            content_hash=content_hash,\n            storage_path=artifact_data.storage_path,\n            meta=artifact_data.metadata\n        )\n\n        session.add(artifact)\n        await session.commit()\n        await session.refresh(artifact)\n\n        return artifact\n\n    async def search_artifacts(\n        self,\n        session: AsyncSession,\n        query: Optional[str] = None,\n        artifact_type: Optional[str] = None,\n        tags: Optional[List[str]] = None,\n        min_impact_score: Optional[float] = None,\n        limit: int = 20\n    ) -> List[Artifact]:\n        \"\"\"\n        Search artifacts by query, type, tags, and impact score\n\n        Returns top matching artifacts sorted by impact score\n        \"\"\"\n        stmt = select(Artifact).where(Artifact.is_active == True)\n\n        # Filter by type\n        if artifact_type:\n            stmt = stmt.where(Artifact.type == artifact_type)\n\n        # Filter by tags (any match) - works for both PostgreSQL ARRAY and SQLite JSON\n        if tags:\n            # For SQLite with JSONEncodedList, we need to use LIKE for pattern matching\n            tag_conditions = []\n            for tag in tags:\n                # Use LIKE to search for the tag in the JSON string\n                tag_conditions.append(Artifact.tags.cast(Text).like(f'%\"{tag}\"%'))\n            if tag_conditions:\n                stmt = stmt.where(or_(*tag_conditions))\n\n        # Filter by minimum impact score\n        if min_impact_score:\n            stmt = stmt.where(Artifact.avg_impact_score >= min_impact_score)\n\n        # Text search in name (metadata search requires jsonb support)\n        if query:\n            stmt = stmt.where(Artifact.name.ilike(f\"%{query}%\"))\n\n        # Order by impact score (most valuable first)\n        stmt = stmt.order_by(Artifact.avg_impact_score.desc()).limit(limit)\n\n        result = await session.execute(stmt)\n        return result.scalars().all()\n\n    async def log_usage(\n        self,\n        session: AsyncSession,\n        artifact_id: str,\n        project_id: str,\n        impact_score: Optional[float] = None,\n        context: Optional[Dict[str, Any]] = None\n    ) -> ArtifactUsage:\n        \"\"\"\n        Log artifact usage in a project\n\n        This is called whenever an artifact is used. Impact score can be provided\n        now or calculated later after project completion.\n        \"\"\"\n        import uuid as uuid_lib\n\n        # Convert string IDs to UUIDs\n        artifact_uuid = uuid_lib.UUID(artifact_id) if isinstance(artifact_id, str) else artifact_id\n        project_uuid = uuid_lib.UUID(project_id) if isinstance(project_id, str) else project_id\n\n        usage = ArtifactUsage(\n            artifact_id=artifact_uuid,\n            project_id=project_uuid,\n            impact_score=impact_score,\n            context=context or {}\n        )\n\n        session.add(usage)\n\n        # Increment usage count\n        stmt = select(Artifact).where(Artifact.id == artifact_uuid)\n        result = await session.execute(stmt)\n        artifact = result.scalar_one()\n        artifact.usage_count += 1\n\n        await session.commit()\n        await session.refresh(usage)\n\n        return usage\n\n    async def update_impact_score(\n        self,\n        session: AsyncSession,\n        artifact_id: str\n    ) -> float:\n        \"\"\"\n        Calculate and update average impact score for an artifact\n\n        Impact score = average of all usage impact scores\n        Called after projects complete to update artifact value\n        \"\"\"\n        stmt = select(func.avg(ArtifactUsage.impact_score)).where(\n            and_(\n                ArtifactUsage.artifact_id == artifact_id,\n                ArtifactUsage.impact_score.isnot(None)\n            )\n        )\n\n        result = await session.execute(stmt)\n        avg_score = result.scalar() or 0.0\n\n        # Update artifact\n        stmt = select(Artifact).where(Artifact.id == artifact_id)\n        result = await session.execute(stmt)\n        artifact = result.scalar_one()\n        artifact.avg_impact_score = avg_score\n\n        await session.commit()\n\n        return avg_score\n\n    async def get_top_artifacts(\n        self,\n        session: AsyncSession,\n        artifact_type: Optional[str] = None,\n        limit: int = 10\n    ) -> List[Artifact]:\n        \"\"\"Get top artifacts by impact score\"\"\"\n        stmt = select(Artifact).where(Artifact.is_active == True)\n\n        if artifact_type:\n            stmt = stmt.where(Artifact.type == artifact_type)\n\n        stmt = stmt.order_by(\n            Artifact.avg_impact_score.desc(),\n            Artifact.usage_count.desc()\n        ).limit(limit)\n\n        result = await session.execute(stmt)\n        return result.scalars().all()\n\n    async def get_artifact_analytics(\n        self,\n        session: AsyncSession,\n        artifact_id: str\n    ) -> Dict[str, Any]:\n        \"\"\"Get analytics for a specific artifact\"\"\"\n        # Get artifact\n        stmt = select(Artifact).where(Artifact.id == artifact_id)\n        result = await session.execute(stmt)\n        artifact = result.scalar_one()\n\n        # Get usage statistics\n        usage_stmt = select(ArtifactUsage).where(ArtifactUsage.artifact_id == artifact_id)\n        usage_result = await session.execute(usage_stmt)\n        usages = usage_result.scalars().all()\n\n        # Calculate stats\n        impact_scores = [u.impact_score for u in usages if u.impact_score is not None]\n\n        return {\n            \"artifact_id\": str(artifact_id),\n            \"name\": artifact.name,\n            \"type\": artifact.type,\n            \"version\": artifact.version,\n            \"usage_count\": artifact.usage_count,\n            \"avg_impact_score\": artifact.avg_impact_score,\n            \"total_projects\": len(usages),\n            \"impact_scores\": impact_scores,\n            \"created_at\": artifact.created_at,\n            \"created_by\": artifact.created_by\n        }\n\n    @staticmethod\n    def _calculate_hash(content: str) -> str:\n        \"\"\"Calculate SHA-256 hash of content\"\"\"\n        return hashlib.sha256(content.encode()).hexdigest()\n",
    "README.md": "# ML Artifact Registry\n\nMeta-learning platform for reusable ML components.\n\n```python\nfrom artifact_registry import ArtifactRegistry\n\nregistry = ArtifactRegistry()\nawait registry.create_artifact(\n    session, name='user-features',\n    artifact_type='feature_pipeline'\n)\n```\n"
  },
  "dependencies": {
    "python": ">=3.8",
    "runtime": [
      "sqlalchemy>=2.0.0",
      "asyncpg>=0.29.0",
      "fastapi>=0.100.0"
    ],
    "dev": []
  },
  "metadata": {
    "created_at": "2025-10-13T00:00:00Z",
    "curated": true,
    "production_ready": true
  }
}