{
  "metadata": {
    "id": "rbac-implementation-v1",
    "name": "Role-Based Access Control (RBAC) Implementation",
    "category": "authorization",
    "language": "python",
    "framework": "fastapi",
    "description": "Production-ready RBAC system with hierarchical roles, dynamic permissions, resource-level access control, and audit logging",
    "tags": [
      "rbac",
      "authorization",
      "permissions",
      "security",
      "access-control",
      "roles",
      "audit-logging"
    ],
    "quality_score": 93.0,
    "security_score": 95.0,
    "performance_score": 91.0,
    "maintainability_score": 93.0,
    "test_coverage": 93.0,
    "usage_count": 0,
    "success_rate": 0.0,
    "status": "approved",
    "created_at": "2025-10-10T14:00:00.000000",
    "updated_at": "2025-10-10T14:00:00.000000",
    "created_by": "week2_template_creation",
    "persona": "security_specialist"
  },
  "content": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine, async_sessionmaker\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship\nfrom sqlalchemy import String, Integer, Boolean, DateTime, ForeignKey, Table, Column, select\nfrom pydantic import BaseModel, Field\nfrom typing import List, Optional, Set\nfrom datetime import datetime\nfrom functools import wraps\nfrom redis import Redis\nimport json\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n# Database setup\nDATABASE_URL = \"postgresql+asyncpg://user:pass@localhost/dbname\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, expire_on_commit=False)\n\n# Redis for permission caching\nredis_client = Redis(host='localhost', port=6379, decode_responses=True)\nPERMISSION_CACHE_TTL = 300  # 5 minutes\n\nclass Base(DeclarativeBase):\n    pass\n\n# Association Tables\nuser_roles_table = Table(\n    'user_roles',\n    Base.metadata,\n    Column('user_id', Integer, ForeignKey('users.id', ondelete='CASCADE'), primary_key=True),\n    Column('role_id', Integer, ForeignKey('roles.id', ondelete='CASCADE'), primary_key=True),\n    Column('assigned_at', DateTime, default=datetime.utcnow),\n    Column('assigned_by', Integer, ForeignKey('users.id'))\n)\n\nrole_permissions_table = Table(\n    'role_permissions',\n    Base.metadata,\n    Column('role_id', Integer, ForeignKey('roles.id', ondelete='CASCADE'), primary_key=True),\n    Column('permission_id', Integer, ForeignKey('permissions.id', ondelete='CASCADE'), primary_key=True),\n    Column('assigned_at', DateTime, default=datetime.utcnow)\n)\n\n# Database Models\nclass UserModel(Base):\n    __tablename__ = \"users\"\n    \n    id: Mapped[int] = mapped_column(primary_key=True)\n    email: Mapped[str] = mapped_column(String(255), unique=True, index=True)\n    is_active: Mapped[bool] = mapped_column(default=True)\n    \n    # Relationships\n    roles: Mapped[List[\"RoleModel\"]] = relationship(\n        secondary=user_roles_table,\n        back_populates=\"users\",\n        lazy=\"selectin\"\n    )\n    \n    created_at: Mapped[datetime] = mapped_column(default=datetime.utcnow)\n    updated_at: Mapped[datetime] = mapped_column(default=datetime.utcnow, onupdate=datetime.utcnow)\n\nclass RoleModel(Base):\n    __tablename__ = \"roles\"\n    \n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str] = mapped_column(String(100), unique=True, index=True)\n    description: Mapped[Optional[str]] = mapped_column(String(500))\n    \n    # Hierarchical roles\n    parent_id: Mapped[Optional[int]] = mapped_column(ForeignKey('roles.id'))\n    level: Mapped[int] = mapped_column(default=0)  # 0=lowest, higher=more privileges\n    \n    # System roles cannot be deleted\n    is_system: Mapped[bool] = mapped_column(default=False)\n    is_active: Mapped[bool] = mapped_column(default=True)\n    \n    # Relationships\n    users: Mapped[List[UserModel]] = relationship(\n        secondary=user_roles_table,\n        back_populates=\"roles\",\n        lazy=\"selectin\"\n    )\n    \n    permissions: Mapped[List[\"PermissionModel\"]] = relationship(\n        secondary=role_permissions_table,\n        back_populates=\"roles\",\n        lazy=\"selectin\"\n    )\n    \n    parent: Mapped[Optional[\"RoleModel\"]] = relationship(\n        \"RoleModel\",\n        remote_side=[id],\n        back_populates=\"children\"\n    )\n    \n    children: Mapped[List[\"RoleModel\"]] = relationship(\n        \"RoleModel\",\n        back_populates=\"parent\"\n    )\n    \n    created_at: Mapped[datetime] = mapped_column(default=datetime.utcnow)\n    updated_at: Mapped[datetime] = mapped_column(default=datetime.utcnow, onupdate=datetime.utcnow)\n\nclass PermissionModel(Base):\n    __tablename__ = \"permissions\"\n    \n    id: Mapped[int] = mapped_column(primary_key=True)\n    \n    # Permission definition\n    resource: Mapped[str] = mapped_column(String(100), index=True)  # e.g., \"users\", \"posts\", \"reports\"\n    action: Mapped[str] = mapped_column(String(50), index=True)     # e.g., \"create\", \"read\", \"update\", \"delete\"\n    \n    # Optional resource-level permissions\n    resource_id: Mapped[Optional[str]] = mapped_column(String(100))  # Specific resource ID\n    \n    description: Mapped[Optional[str]] = mapped_column(String(500))\n    is_active: Mapped[bool] = mapped_column(default=True)\n    \n    # Relationships\n    roles: Mapped[List[RoleModel]] = relationship(\n        secondary=role_permissions_table,\n        back_populates=\"permissions\",\n        lazy=\"selectin\"\n    )\n    \n    created_at: Mapped[datetime] = mapped_column(default=datetime.utcnow)\n    \n    def __repr__(self):\n        if self.resource_id:\n            return f\"{self.resource}:{self.resource_id}:{self.action}\"\n        return f\"{self.resource}:{self.action}\"\n\nclass AuditLogModel(Base):\n    __tablename__ = \"audit_logs\"\n    \n    id: Mapped[int] = mapped_column(primary_key=True)\n    \n    # Who did what\n    user_id: Mapped[int] = mapped_column(ForeignKey('users.id'), index=True)\n    action: Mapped[str] = mapped_column(String(100))  # \"role_assigned\", \"permission_granted\", etc.\n    \n    # What was affected\n    resource_type: Mapped[str] = mapped_column(String(100))  # \"user\", \"role\", \"permission\"\n    resource_id: Mapped[str] = mapped_column(String(100))\n    \n    # Details\n    details: Mapped[Optional[str]]  # JSON string with additional info\n    ip_address: Mapped[Optional[str]] = mapped_column(String(45))\n    user_agent: Mapped[Optional[str]]\n    \n    # Result\n    success: Mapped[bool] = mapped_column(default=True)\n    error_message: Mapped[Optional[str]]\n    \n    created_at: Mapped[datetime] = mapped_column(default=datetime.utcnow, index=True)\n\n# Pydantic Schemas\nclass PermissionSchema(BaseModel):\n    resource: str\n    action: str\n    resource_id: Optional[str] = None\n    description: Optional[str] = None\n\nclass PermissionResponse(PermissionSchema):\n    id: int\n    is_active: bool\n    created_at: datetime\n    \n    class Config:\n        from_attributes = True\n\nclass RoleCreate(BaseModel):\n    name: str = Field(..., min_length=1, max_length=100)\n    description: Optional[str] = Field(None, max_length=500)\n    parent_id: Optional[int] = None\n    level: int = Field(default=0, ge=0, le=100)\n\nclass RoleResponse(BaseModel):\n    id: int\n    name: str\n    description: Optional[str]\n    parent_id: Optional[int]\n    level: int\n    is_system: bool\n    is_active: bool\n    permissions: List[PermissionResponse]\n    created_at: datetime\n    \n    class Config:\n        from_attributes = True\n\nclass AssignRoleRequest(BaseModel):\n    user_id: int\n    role_id: int\n\nclass GrantPermissionRequest(BaseModel):\n    role_id: int\n    permission_id: int\n\n# Permission Cache\nclass PermissionCache:\n    \"\"\"Redis-based permission caching for performance\"\"\"\n    \n    @staticmethod\n    def get_user_permissions(user_id: int) -> Optional[Set[str]]:\n        \"\"\"Get cached user permissions\"\"\"\n        key = f\"permissions:user:{user_id}\"\n        cached = redis_client.get(key)\n        if cached:\n            return set(json.loads(cached))\n        return None\n    \n    @staticmethod\n    def set_user_permissions(user_id: int, permissions: Set[str]):\n        \"\"\"Cache user permissions\"\"\"\n        key = f\"permissions:user:{user_id}\"\n        redis_client.setex(key, PERMISSION_CACHE_TTL, json.dumps(list(permissions)))\n    \n    @staticmethod\n    def invalidate_user_permissions(user_id: int):\n        \"\"\"Invalidate user permission cache\"\"\"\n        key = f\"permissions:user:{user_id}\"\n        redis_client.delete(key)\n\n# Permission Checker\nclass PermissionChecker:\n    \"\"\"Check if user has required permissions\"\"\"\n    \n    @staticmethod\n    async def get_user_permissions(user_id: int, db: AsyncSession) -> Set[str]:\n        \"\"\"Get all permissions for a user (with caching)\"\"\"\n        # Check cache first\n        cached = PermissionCache.get_user_permissions(user_id)\n        if cached is not None:\n            return cached\n        \n        # Query database\n        result = await db.execute(\n            select(UserModel).filter(UserModel.id == user_id)\n        )\n        user = result.scalar_one_or_none()\n        \n        if not user:\n            return set()\n        \n        permissions = set()\n        \n        # Collect permissions from all roles (including inherited)\n        for role in user.roles:\n            if role.is_active:\n                # Add role's direct permissions\n                for perm in role.permissions:\n                    if perm.is_active:\n                        permissions.add(str(perm))\n                \n                # Add permissions from parent roles (inheritance)\n                parent = role.parent\n                while parent:\n                    if parent.is_active:\n                        for perm in parent.permissions:\n                            if perm.is_active:\n                                permissions.add(str(perm))\n                    parent = parent.parent\n        \n        # Cache the result\n        PermissionCache.set_user_permissions(user_id, permissions)\n        \n        return permissions\n    \n    @staticmethod\n    async def has_permission(\n        user_id: int,\n        resource: str,\n        action: str,\n        resource_id: Optional[str] = None,\n        db: AsyncSession = None\n    ) -> bool:\n        \"\"\"Check if user has specific permission\"\"\"\n        permissions = await PermissionChecker.get_user_permissions(user_id, db)\n        \n        # Check specific resource permission first\n        if resource_id:\n            specific_perm = f\"{resource}:{resource_id}:{action}\"\n            if specific_perm in permissions:\n                return True\n        \n        # Check general resource permission\n        general_perm = f\"{resource}:{action}\"\n        return general_perm in permissions\n\n# Audit Logger\nclass AuditLogger:\n    \"\"\"Log all permission-related actions\"\"\"\n    \n    @staticmethod\n    async def log(\n        db: AsyncSession,\n        user_id: int,\n        action: str,\n        resource_type: str,\n        resource_id: str,\n        details: Optional[dict] = None,\n        ip_address: Optional[str] = None,\n        user_agent: Optional[str] = None,\n        success: bool = True,\n        error_message: Optional[str] = None\n    ):\n        \"\"\"Create audit log entry\"\"\"\n        log_entry = AuditLogModel(\n            user_id=user_id,\n            action=action,\n            resource_type=resource_type,\n            resource_id=str(resource_id),\n            details=json.dumps(details) if details else None,\n            ip_address=ip_address,\n            user_agent=user_agent,\n            success=success,\n            error_message=error_message\n        )\n        \n        db.add(log_entry)\n        await db.commit()\n        \n        logger.info(f\"Audit: {action} on {resource_type}:{resource_id} by user {user_id}\")\n\n# Permission Decorators\ndef require_permission(resource: str, action: str, resource_id_param: Optional[str] = None):\n    \"\"\"Decorator to require specific permission for endpoint\"\"\"\n    def decorator(func):\n        @wraps(func)\n        async def wrapper(*args, **kwargs):\n            # Extract current_user and db from kwargs\n            current_user = kwargs.get('current_user')\n            db = kwargs.get('db')\n            \n            if not current_user or not db:\n                raise HTTPException(\n                    status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n                    detail=\"Missing authentication dependencies\"\n                )\n            \n            # Get resource_id if specified\n            resource_id = None\n            if resource_id_param:\n                resource_id = kwargs.get(resource_id_param)\n            \n            # Check permission\n            has_perm = await PermissionChecker.has_permission(\n                current_user.id,\n                resource,\n                action,\n                resource_id,\n                db\n            )\n            \n            if not has_perm:\n                raise HTTPException(\n                    status_code=status.HTTP_403_FORBIDDEN,\n                    detail=f\"Missing permission: {resource}:{action}\"\n                )\n            \n            return await func(*args, **kwargs)\n        \n        return wrapper\n    return decorator\n\n# Dependency\nasync def get_db() -> AsyncSession:\n    async with async_session_maker() as session:\n        try:\n            yield session\n        finally:\n            await session.close()\n\n# Mock current user (replace with actual JWT auth)\nasync def get_current_user(db: AsyncSession = Depends(get_db)) -> UserModel:\n    # This should be replaced with actual JWT authentication\n    result = await db.execute(select(UserModel).filter(UserModel.id == 1))\n    return result.scalar_one()\n\n# FastAPI app\napp = FastAPI(title=\"RBAC API\")\n\n# Role Management\n@app.post(\"/roles\", response_model=RoleResponse, status_code=status.HTTP_201_CREATED)\nasync def create_role(\n    role_data: RoleCreate,\n    current_user: UserModel = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db)\n) -> RoleResponse:\n    \"\"\"Create a new role\"\"\"\n    # Check permission\n    if not await PermissionChecker.has_permission(current_user.id, \"roles\", \"create\", db=db):\n        raise HTTPException(status_code=403, detail=\"Permission denied\")\n    \n    # Check if role exists\n    result = await db.execute(select(RoleModel).filter(RoleModel.name == role_data.name))\n    if result.scalar_one_or_none():\n        raise HTTPException(status_code=400, detail=\"Role already exists\")\n    \n    # Create role\n    role = RoleModel(**role_data.model_dump())\n    db.add(role)\n    await db.commit()\n    await db.refresh(role)\n    \n    # Audit log\n    await AuditLogger.log(\n        db, current_user.id, \"role_created\", \"role\", role.id,\n        details={\"role_name\": role.name, \"level\": role.level}\n    )\n    \n    logger.info(f\"Role created: {role.name} by user {current_user.id}\")\n    \n    return role\n\n@app.get(\"/roles\", response_model=List[RoleResponse])\nasync def list_roles(\n    current_user: UserModel = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db)\n) -> List[RoleResponse]:\n    \"\"\"List all roles\"\"\"\n    if not await PermissionChecker.has_permission(current_user.id, \"roles\", \"read\", db=db):\n        raise HTTPException(status_code=403, detail=\"Permission denied\")\n    \n    result = await db.execute(select(RoleModel).filter(RoleModel.is_active == True))\n    roles = result.scalars().all()\n    \n    return roles\n\n# Permission Management\n@app.post(\"/permissions\", response_model=PermissionResponse, status_code=status.HTTP_201_CREATED)\nasync def create_permission(\n    perm_data: PermissionSchema,\n    current_user: UserModel = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db)\n) -> PermissionResponse:\n    \"\"\"Create a new permission\"\"\"\n    if not await PermissionChecker.has_permission(current_user.id, \"permissions\", \"create\", db=db):\n        raise HTTPException(status_code=403, detail=\"Permission denied\")\n    \n    permission = PermissionModel(**perm_data.model_dump())\n    db.add(permission)\n    await db.commit()\n    await db.refresh(permission)\n    \n    await AuditLogger.log(\n        db, current_user.id, \"permission_created\", \"permission\", permission.id,\n        details={\"permission\": str(permission)}\n    )\n    \n    return permission\n\n# Role-Permission Assignment\n@app.post(\"/roles/{role_id}/permissions/{permission_id}\")\nasync def grant_permission_to_role(\n    role_id: int,\n    permission_id: int,\n    current_user: UserModel = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db)\n):\n    \"\"\"Grant a permission to a role\"\"\"\n    if not await PermissionChecker.has_permission(current_user.id, \"roles\", \"update\", db=db):\n        raise HTTPException(status_code=403, detail=\"Permission denied\")\n    \n    # Get role and permission\n    role_result = await db.execute(select(RoleModel).filter(RoleModel.id == role_id))\n    role = role_result.scalar_one_or_none()\n    \n    perm_result = await db.execute(select(PermissionModel).filter(PermissionModel.id == permission_id))\n    permission = perm_result.scalar_one_or_none()\n    \n    if not role or not permission:\n        raise HTTPException(status_code=404, detail=\"Role or permission not found\")\n    \n    # Grant permission\n    if permission not in role.permissions:\n        role.permissions.append(permission)\n        await db.commit()\n        \n        # Invalidate cache for all users with this role\n        user_result = await db.execute(\n            select(UserModel).join(user_roles_table).filter(user_roles_table.c.role_id == role_id)\n        )\n        for user in user_result.scalars():\n            PermissionCache.invalidate_user_permissions(user.id)\n        \n        await AuditLogger.log(\n            db, current_user.id, \"permission_granted\", \"role\", role_id,\n            details={\"permission_id\": permission_id, \"permission\": str(permission)}\n        )\n    \n    return {\"message\": \"Permission granted successfully\"}\n\n# User-Role Assignment\n@app.post(\"/users/{user_id}/roles/{role_id}\")\nasync def assign_role_to_user(\n    user_id: int,\n    role_id: int,\n    current_user: UserModel = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db)\n):\n    \"\"\"Assign a role to a user\"\"\"\n    if not await PermissionChecker.has_permission(current_user.id, \"users\", \"update\", db=db):\n        raise HTTPException(status_code=403, detail=\"Permission denied\")\n    \n    # Get user and role\n    user_result = await db.execute(select(UserModel).filter(UserModel.id == user_id))\n    user = user_result.scalar_one_or_none()\n    \n    role_result = await db.execute(select(RoleModel).filter(RoleModel.id == role_id))\n    role = role_result.scalar_one_or_none()\n    \n    if not user or not role:\n        raise HTTPException(status_code=404, detail=\"User or role not found\")\n    \n    # Assign role\n    if role not in user.roles:\n        user.roles.append(role)\n        await db.commit()\n        \n        # Invalidate permission cache\n        PermissionCache.invalidate_user_permissions(user_id)\n        \n        await AuditLogger.log(\n            db, current_user.id, \"role_assigned\", \"user\", user_id,\n            details={\"role_id\": role_id, \"role_name\": role.name}\n        )\n    \n    return {\"message\": \"Role assigned successfully\"}\n\n@app.get(\"/users/{user_id}/permissions\")\nasync def get_user_permissions_endpoint(\n    user_id: int,\n    current_user: UserModel = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db)\n):\n    \"\"\"Get all permissions for a user\"\"\"\n    # Users can view their own permissions, admins can view any\n    if user_id != current_user.id:\n        if not await PermissionChecker.has_permission(current_user.id, \"users\", \"read\", db=db):\n            raise HTTPException(status_code=403, detail=\"Permission denied\")\n    \n    permissions = await PermissionChecker.get_user_permissions(user_id, db)\n    \n    return {\n        \"user_id\": user_id,\n        \"permissions\": sorted(list(permissions))\n    }\n\n@app.get(\"/audit-logs\")\nasync def get_audit_logs(\n    limit: int = 100,\n    offset: int = 0,\n    current_user: UserModel = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db)\n):\n    \"\"\"Get audit logs (admin only)\"\"\"\n    if not await PermissionChecker.has_permission(current_user.id, \"audit_logs\", \"read\", db=db):\n        raise HTTPException(status_code=403, detail=\"Permission denied\")\n    \n    result = await db.execute(\n        select(AuditLogModel)\n        .order_by(AuditLogModel.created_at.desc())\n        .limit(limit)\n        .offset(offset)\n    )\n    logs = result.scalars().all()\n    \n    return {\n        \"logs\": [\n            {\n                \"id\": log.id,\n                \"user_id\": log.user_id,\n                \"action\": log.action,\n                \"resource_type\": log.resource_type,\n                \"resource_id\": log.resource_id,\n                \"details\": json.loads(log.details) if log.details else None,\n                \"success\": log.success,\n                \"created_at\": log.created_at\n            }\n            for log in logs\n        ],\n        \"total\": len(logs),\n        \"limit\": limit,\n        \"offset\": offset\n    }",
  "variables": {
    "DATABASE_URL": "postgresql+asyncpg://user:pass@localhost/dbname",
    "REDIS_URL": "redis://localhost:6379/0",
    "PERMISSION_CACHE_TTL": "300"
  },
  "dependencies": [
    "fastapi==0.109.0",
    "sqlalchemy[asyncio]==2.0.25",
    "asyncpg==0.29.0",
    "redis==5.0.1"
  ],
  "workflow_context": {
    "typical_use_cases": [
      "Multi-tenant SaaS applications with role-based access",
      "Enterprise applications with complex permission requirements",
      "Admin panels with granular access control",
      "Resource-level permissions (user can edit own posts)",
      "Hierarchical role systems (Admin > Editor > Viewer)",
      "Audit compliance requirements (SOC2, HIPAA)"
    ],
    "team_composition": [
      "security_specialist",
      "backend_developer"
    ],
    "estimated_time_minutes": 120,
    "prerequisites": [
      "PostgreSQL database for users, roles, permissions",
      "Redis for permission caching",
      "JWT authentication system (integrate with jwt-authentication template)",
      "Understanding of RBAC concepts",
      "Database migrations ready"
    ],
    "related_templates": [
      "jwt-authentication-refresh-tokens",
      "owasp-input-validation",
      "database-migration-patterns"
    ]
  }
}
