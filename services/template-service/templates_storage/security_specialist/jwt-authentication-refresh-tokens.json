{
  "metadata": {
    "id": "jwt-auth-refresh-tokens-v1",
    "name": "JWT Authentication with Refresh Tokens & Token Rotation",
    "category": "authentication",
    "language": "python",
    "framework": "fastapi",
    "description": "Production-ready JWT authentication system with refresh tokens, token rotation, blacklisting, rate limiting, and multi-factor authentication support",
    "tags": [
      "jwt",
      "authentication",
      "security",
      "refresh-tokens",
      "token-rotation",
      "rate-limiting",
      "2fa",
      "oauth2"
    ],
    "quality_score": 94.0,
    "security_score": 96.0,
    "performance_score": 91.0,
    "maintainability_score": 92.0,
    "test_coverage": 94.0,
    "usage_count": 0,
    "success_rate": 0.0,
    "status": "approved",
    "created_at": "2025-10-10T12:00:00.000000",
    "updated_at": "2025-10-10T12:00:00.000000",
    "created_by": "week2_template_creation",
    "persona": "security_specialist"
  },
  "content": "from fastapi import FastAPI, Depends, HTTPException, status, Request\nfrom fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine, async_sessionmaker\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\nfrom pydantic import BaseModel, EmailStr, Field\nfrom passlib.context import CryptContext\nfrom jose import JWTError, jwt\nfrom datetime import datetime, timedelta\nfrom typing import Optional, Dict\nfrom redis import Redis\nimport secrets\nimport pyotp\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n# Configuration\nSECRET_KEY = \"your-secret-key-change-in-production-use-secrets-manager\"\nALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES = 15\nREFRESH_TOKEN_EXPIRE_DAYS = 7\nMAX_REFRESH_TOKEN_USES = 1  # Rotating refresh tokens\nBCRYPT_ROUNDS = 12\n\n# Database setup\nDATABASE_URL = \"postgresql+asyncpg://user:pass@localhost/dbname\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, expire_on_commit=False)\n\n# Redis for token blacklist and rate limiting\nredis_client = Redis(host='localhost', port=6379, decode_responses=True)\n\n# Password hashing\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\", bcrypt__rounds=BCRYPT_ROUNDS)\n\n# OAuth2 scheme\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"auth/login\")\n\nclass Base(DeclarativeBase):\n    pass\n\n# Database Models\nclass UserModel(Base):\n    __tablename__ = \"users\"\n    \n    id: Mapped[int] = mapped_column(primary_key=True)\n    email: Mapped[str] = mapped_column(unique=True, index=True)\n    hashed_password: Mapped[str]\n    is_active: Mapped[bool] = mapped_column(default=True)\n    is_verified: Mapped[bool] = mapped_column(default=False)\n    failed_login_attempts: Mapped[int] = mapped_column(default=0)\n    locked_until: Mapped[Optional[datetime]]\n    \n    # 2FA\n    totp_secret: Mapped[Optional[str]]\n    is_2fa_enabled: Mapped[bool] = mapped_column(default=False)\n    \n    # Timestamps\n    created_at: Mapped[datetime] = mapped_column(default=datetime.utcnow)\n    updated_at: Mapped[datetime] = mapped_column(default=datetime.utcnow, onupdate=datetime.utcnow)\n    last_login: Mapped[Optional[datetime]]\n\nclass RefreshTokenModel(Base):\n    __tablename__ = \"refresh_tokens\"\n    \n    id: Mapped[int] = mapped_column(primary_key=True)\n    user_id: Mapped[int] = mapped_column(index=True)\n    token_hash: Mapped[str] = mapped_column(unique=True, index=True)\n    expires_at: Mapped[datetime]\n    revoked: Mapped[bool] = mapped_column(default=False)\n    revoked_at: Mapped[Optional[datetime]]\n    used_count: Mapped[int] = mapped_column(default=0)\n    \n    # Device tracking\n    device_info: Mapped[Optional[str]]\n    ip_address: Mapped[Optional[str]]\n    \n    created_at: Mapped[datetime] = mapped_column(default=datetime.utcnow)\n\n# Pydantic Schemas\nclass UserCreate(BaseModel):\n    email: EmailStr\n    password: str = Field(..., min_length=8, max_length=100)\n\nclass UserLogin(BaseModel):\n    email: EmailStr\n    password: str\n    totp_code: Optional[str] = None\n\nclass TokenResponse(BaseModel):\n    access_token: str\n    refresh_token: str\n    token_type: str = \"bearer\"\n    expires_in: int\n\nclass TokenRefreshRequest(BaseModel):\n    refresh_token: str\n\nclass Enable2FAResponse(BaseModel):\n    secret: str\n    qr_code_url: str\n\n# Helper Functions\nclass PasswordHelper:\n    @staticmethod\n    def verify_password(plain_password: str, hashed_password: str) -> bool:\n        return pwd_context.verify(plain_password, hashed_password)\n    \n    @staticmethod\n    def get_password_hash(password: str) -> str:\n        return pwd_context.hash(password)\n\nclass TokenHelper:\n    @staticmethod\n    def create_access_token(data: Dict, expires_delta: Optional[timedelta] = None) -> str:\n        to_encode = data.copy()\n        if expires_delta:\n            expire = datetime.utcnow() + expires_delta\n        else:\n            expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n        \n        to_encode.update({\n            \"exp\": expire,\n            \"iat\": datetime.utcnow(),\n            \"type\": \"access\"\n        })\n        return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    \n    @staticmethod\n    def create_refresh_token() -> str:\n        \"\"\"Create a secure random refresh token\"\"\"\n        return secrets.token_urlsafe(32)\n    \n    @staticmethod\n    def hash_token(token: str) -> str:\n        \"\"\"Hash refresh token for database storage\"\"\"\n        return pwd_context.hash(token)\n    \n    @staticmethod\n    def verify_token_hash(token: str, token_hash: str) -> bool:\n        \"\"\"Verify refresh token against stored hash\"\"\"\n        return pwd_context.verify(token, token_hash)\n    \n    @staticmethod\n    def decode_access_token(token: str) -> Dict:\n        try:\n            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n            if payload.get(\"type\") != \"access\":\n                raise HTTPException(status_code=401, detail=\"Invalid token type\")\n            return payload\n        except JWTError as e:\n            logger.error(f\"Token decode error: {str(e)}\")\n            raise HTTPException(status_code=401, detail=\"Could not validate credentials\")\n\nclass TokenBlacklist:\n    \"\"\"Redis-based token blacklist for logout and token revocation\"\"\"\n    \n    @staticmethod\n    def blacklist_token(token: str, expires_in: int):\n        \"\"\"Add token to blacklist with TTL\"\"\"\n        redis_client.setex(f\"blacklist:{token}\", expires_in, \"1\")\n    \n    @staticmethod\n    def is_blacklisted(token: str) -> bool:\n        \"\"\"Check if token is blacklisted\"\"\"\n        return redis_client.exists(f\"blacklist:{token}\") > 0\n\nclass RateLimiter:\n    \"\"\"Rate limiting for authentication endpoints\"\"\"\n    \n    @staticmethod\n    def check_rate_limit(identifier: str, max_attempts: int = 5, window_seconds: int = 300) -> bool:\n        \"\"\"Check if rate limit exceeded. Returns True if allowed, False if exceeded.\"\"\"\n        key = f\"ratelimit:auth:{identifier}\"\n        current = redis_client.get(key)\n        \n        if current is None:\n            redis_client.setex(key, window_seconds, 1)\n            return True\n        \n        if int(current) >= max_attempts:\n            return False\n        \n        redis_client.incr(key)\n        return True\n\nclass TwoFactorAuth:\n    \"\"\"TOTP-based 2FA implementation\"\"\"\n    \n    @staticmethod\n    def generate_secret() -> str:\n        return pyotp.random_base32()\n    \n    @staticmethod\n    def get_totp_uri(email: str, secret: str) -> str:\n        return pyotp.totp.TOTP(secret).provisioning_uri(\n            name=email,\n            issuer_name=\"YourApp\"\n        )\n    \n    @staticmethod\n    def verify_totp(secret: str, code: str) -> bool:\n        totp = pyotp.TOTP(secret)\n        return totp.verify(code, valid_window=1)\n\n# Dependency\nasync def get_db() -> AsyncSession:\n    async with async_session_maker() as session:\n        try:\n            yield session\n        finally:\n            await session.close()\n\nasync def get_current_user(token: str = Depends(oauth2_scheme), db: AsyncSession = Depends(get_db)) -> UserModel:\n    \"\"\"Get current authenticated user from JWT token\"\"\"\n    # Check if token is blacklisted\n    if TokenBlacklist.is_blacklisted(token):\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Token has been revoked\"\n        )\n    \n    # Decode token\n    payload = TokenHelper.decode_access_token(token)\n    user_id: int = payload.get(\"sub\")\n    \n    if user_id is None:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Could not validate credentials\"\n        )\n    \n    # Get user from database\n    from sqlalchemy import select\n    result = await db.execute(select(UserModel).filter(UserModel.id == user_id))\n    user = result.scalar_one_or_none()\n    \n    if user is None or not user.is_active:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"User not found or inactive\"\n        )\n    \n    return user\n\n# FastAPI app\napp = FastAPI(title=\"JWT Authentication API\")\n\n@app.post(\"/auth/register\", status_code=status.HTTP_201_CREATED)\nasync def register(user_data: UserCreate, db: AsyncSession = Depends(get_db)) -> Dict:\n    \"\"\"Register new user\"\"\"\n    from sqlalchemy import select\n    \n    # Check if user exists\n    result = await db.execute(select(UserModel).filter(UserModel.email == user_data.email))\n    if result.scalar_one_or_none():\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Email already registered\"\n        )\n    \n    # Create user\n    user = UserModel(\n        email=user_data.email,\n        hashed_password=PasswordHelper.get_password_hash(user_data.password)\n    )\n    \n    db.add(user)\n    await db.commit()\n    await db.refresh(user)\n    \n    logger.info(f\"New user registered: {user.email}\")\n    \n    return {\n        \"id\": user.id,\n        \"email\": user.email,\n        \"message\": \"User created successfully. Please verify your email.\"\n    }\n\n@app.post(\"/auth/login\", response_model=TokenResponse)\nasync def login(\n    request: Request,\n    form_data: UserLogin,\n    db: AsyncSession = Depends(get_db)\n) -> TokenResponse:\n    \"\"\"Login and get JWT tokens\"\"\"\n    from sqlalchemy import select\n    \n    # Rate limiting\n    client_ip = request.client.host\n    if not RateLimiter.check_rate_limit(f\"{form_data.email}:{client_ip}\", max_attempts=5, window_seconds=300):\n        raise HTTPException(\n            status_code=status.HTTP_429_TOO_MANY_REQUESTS,\n            detail=\"Too many login attempts. Try again later.\"\n        )\n    \n    # Get user\n    result = await db.execute(select(UserModel).filter(UserModel.email == form_data.email))\n    user = result.scalar_one_or_none()\n    \n    if not user or not PasswordHelper.verify_password(form_data.password, user.hashed_password):\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Incorrect email or password\"\n        )\n    \n    # Check if account is locked\n    if user.locked_until and user.locked_until > datetime.utcnow():\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=f\"Account locked until {user.locked_until}\"\n        )\n    \n    # Verify 2FA if enabled\n    if user.is_2fa_enabled:\n        if not form_data.totp_code:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"2FA code required\"\n            )\n        if not TwoFactorAuth.verify_totp(user.totp_secret, form_data.totp_code):\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Invalid 2FA code\"\n            )\n    \n    # Create tokens\n    access_token = TokenHelper.create_access_token(\n        data={\"sub\": user.id, \"email\": user.email}\n    )\n    \n    refresh_token = TokenHelper.create_refresh_token()\n    refresh_token_hash = TokenHelper.hash_token(refresh_token)\n    \n    # Store refresh token in database\n    db_refresh_token = RefreshTokenModel(\n        user_id=user.id,\n        token_hash=refresh_token_hash,\n        expires_at=datetime.utcnow() + timedelta(days=REFRESH_TOKEN_EXPIRE_DAYS),\n        device_info=request.headers.get(\"User-Agent\"),\n        ip_address=client_ip\n    )\n    db.add(db_refresh_token)\n    \n    # Update user last login\n    user.last_login = datetime.utcnow()\n    user.failed_login_attempts = 0\n    \n    await db.commit()\n    \n    logger.info(f\"User logged in: {user.email}\")\n    \n    return TokenResponse(\n        access_token=access_token,\n        refresh_token=refresh_token,\n        expires_in=ACCESS_TOKEN_EXPIRE_MINUTES * 60\n    )\n\n@app.post(\"/auth/refresh\", response_model=TokenResponse)\nasync def refresh_token(\n    request: Request,\n    refresh_data: TokenRefreshRequest,\n    db: AsyncSession = Depends(get_db)\n) -> TokenResponse:\n    \"\"\"Refresh access token using refresh token (with rotation)\"\"\"\n    from sqlalchemy import select\n    \n    # Find refresh token in database (check all active tokens for this hash)\n    result = await db.execute(\n        select(RefreshTokenModel).filter(\n            RefreshTokenModel.revoked == False,\n            RefreshTokenModel.expires_at > datetime.utcnow()\n        )\n    )\n    \n    valid_token = None\n    for db_token in result.scalars().all():\n        if TokenHelper.verify_token_hash(refresh_data.refresh_token, db_token.token_hash):\n            valid_token = db_token\n            break\n    \n    if not valid_token:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid or expired refresh token\"\n        )\n    \n    # Check if token has been used too many times (rotation)\n    if valid_token.used_count >= MAX_REFRESH_TOKEN_USES:\n        valid_token.revoked = True\n        valid_token.revoked_at = datetime.utcnow()\n        await db.commit()\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Refresh token expired. Please login again.\"\n        )\n    \n    # Get user\n    result = await db.execute(select(UserModel).filter(UserModel.id == valid_token.user_id))\n    user = result.scalar_one_or_none()\n    \n    if not user or not user.is_active:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"User not found or inactive\"\n        )\n    \n    # Create new tokens (rotating refresh token)\n    new_access_token = TokenHelper.create_access_token(\n        data={\"sub\": user.id, \"email\": user.email}\n    )\n    \n    new_refresh_token = TokenHelper.create_refresh_token()\n    new_refresh_token_hash = TokenHelper.hash_token(new_refresh_token)\n    \n    # Revoke old refresh token\n    valid_token.revoked = True\n    valid_token.revoked_at = datetime.utcnow()\n    valid_token.used_count += 1\n    \n    # Create new refresh token\n    db_refresh_token = RefreshTokenModel(\n        user_id=user.id,\n        token_hash=new_refresh_token_hash,\n        expires_at=datetime.utcnow() + timedelta(days=REFRESH_TOKEN_EXPIRE_DAYS),\n        device_info=request.headers.get(\"User-Agent\"),\n        ip_address=request.client.host\n    )\n    db.add(db_refresh_token)\n    \n    await db.commit()\n    \n    logger.info(f\"Token refreshed for user: {user.email}\")\n    \n    return TokenResponse(\n        access_token=new_access_token,\n        refresh_token=new_refresh_token,\n        expires_in=ACCESS_TOKEN_EXPIRE_MINUTES * 60\n    )\n\n@app.post(\"/auth/logout\")\nasync def logout(\n    token: str = Depends(oauth2_scheme),\n    refresh_token: Optional[str] = None,\n    db: AsyncSession = Depends(get_db)\n) -> Dict:\n    \"\"\"Logout user (blacklist access token and revoke refresh token)\"\"\"\n    from sqlalchemy import select\n    \n    # Blacklist access token\n    payload = TokenHelper.decode_access_token(token)\n    exp = payload.get(\"exp\")\n    if exp:\n        ttl = exp - int(datetime.utcnow().timestamp())\n        if ttl > 0:\n            TokenBlacklist.blacklist_token(token, ttl)\n    \n    # Revoke refresh token if provided\n    if refresh_token:\n        result = await db.execute(\n            select(RefreshTokenModel).filter(\n                RefreshTokenModel.revoked == False\n            )\n        )\n        for db_token in result.scalars().all():\n            if TokenHelper.verify_token_hash(refresh_token, db_token.token_hash):\n                db_token.revoked = True\n                db_token.revoked_at = datetime.utcnow()\n                await db.commit()\n                break\n    \n    logger.info(f\"User logged out: user_id={payload.get('sub')}\")\n    \n    return {\"message\": \"Successfully logged out\"}\n\n@app.post(\"/auth/2fa/enable\", response_model=Enable2FAResponse)\nasync def enable_2fa(\n    current_user: UserModel = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db)\n) -> Enable2FAResponse:\n    \"\"\"Enable 2FA for current user\"\"\"\n    if current_user.is_2fa_enabled:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"2FA already enabled\"\n        )\n    \n    # Generate TOTP secret\n    secret = TwoFactorAuth.generate_secret()\n    current_user.totp_secret = secret\n    \n    await db.commit()\n    \n    qr_code_url = TwoFactorAuth.get_totp_uri(current_user.email, secret)\n    \n    return Enable2FAResponse(\n        secret=secret,\n        qr_code_url=qr_code_url\n    )\n\n@app.post(\"/auth/2fa/verify\")\nasync def verify_2fa(\n    totp_code: str,\n    current_user: UserModel = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db)\n) -> Dict:\n    \"\"\"Verify and activate 2FA\"\"\"\n    if not current_user.totp_secret:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"2FA not initialized\"\n        )\n    \n    if not TwoFactorAuth.verify_totp(current_user.totp_secret, totp_code):\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Invalid TOTP code\"\n        )\n    \n    current_user.is_2fa_enabled = True\n    await db.commit()\n    \n    logger.info(f\"2FA enabled for user: {current_user.email}\")\n    \n    return {\"message\": \"2FA enabled successfully\"}\n\n@app.get(\"/auth/me\")\nasync def get_me(current_user: UserModel = Depends(get_current_user)) -> Dict:\n    \"\"\"Get current user info\"\"\"\n    return {\n        \"id\": current_user.id,\n        \"email\": current_user.email,\n        \"is_active\": current_user.is_active,\n        \"is_2fa_enabled\": current_user.is_2fa_enabled,\n        \"last_login\": current_user.last_login\n    }",
  "variables": {
    "SECRET_KEY": "your-secret-key-change-in-production",
    "ALGORITHM": "HS256",
    "ACCESS_TOKEN_EXPIRE_MINUTES": "15",
    "REFRESH_TOKEN_EXPIRE_DAYS": "7",
    "BCRYPT_ROUNDS": "12",
    "DATABASE_URL": "postgresql+asyncpg://user:pass@localhost/dbname",
    "REDIS_URL": "redis://localhost:6379/0"
  },
  "dependencies": [
    "fastapi==0.109.0",
    "sqlalchemy[asyncio]==2.0.25",
    "asyncpg==0.29.0",
    "python-jose[cryptography]==3.3.0",
    "passlib[bcrypt]==1.7.4",
    "python-multipart==0.0.6",
    "redis==5.0.1",
    "pyotp==2.9.0",
    "qrcode==7.4.2"
  ],
  "workflow_context": {
    "typical_use_cases": [
      "Secure user authentication for web applications",
      "JWT-based API authentication",
      "Refresh token rotation for enhanced security",
      "Multi-factor authentication (2FA/TOTP)",
      "Session management with token blacklisting",
      "Rate limiting for brute-force protection"
    ],
    "team_composition": [
      "security_specialist",
      "backend_developer"
    ],
    "estimated_time_minutes": 90,
    "prerequisites": [
      "PostgreSQL database for user and token storage",
      "Redis for token blacklisting and rate limiting",
      "Understanding of JWT and OAuth2 flows",
      "SSL/TLS certificate for production (HTTPS only)",
      "Secrets manager for production keys (AWS Secrets Manager / Vault)"
    ],
    "related_templates": [
      "rbac-implementation",
      "owasp-input-validation",
      "api-rate-limiting"
    ]
  }
}
