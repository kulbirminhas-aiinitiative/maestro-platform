"""
JSON Storage Adapter
Bridges JSON-based template storage (from maestro-engine) with Git-based central registry

This adapter allows the central registry to work with both:
1. Git-based templates (cloned from repositories)
2. JSON-based templates (generated by maestro-engine workflows)
"""

import json
from datetime import datetime
from pathlib import Path
from typing import Dict, Any, List, Optional
from uuid import UUID, uuid4

import structlog
from pydantic import ValidationError

from .models.template import TemplateResponse, TemplateCreate

logger = structlog.get_logger(__name__)


class JSONStorageAdapter:
    """Adapter for JSON-based template storage."""

    def __init__(self, storage_path: str = "/home/ec2-user/projects/maestro-templates/storage/templates"):
        """
        Initialize adapter.

        Args:
            storage_path: Path to JSON template storage directory
        """
        self.storage_path = Path(storage_path)
        self.storage_path.mkdir(parents=True, exist_ok=True)
        logger.info("json_adapter_initialized", storage_path=str(self.storage_path))

    async def list_json_templates(
        self,
        language: Optional[str] = None,
        category: Optional[str] = None,
        min_quality_score: Optional[float] = None
    ) -> List[Dict[str, Any]]:
        """
        List all JSON templates with optional filtering.

        Args:
            language: Filter by language
            category: Filter by category
            min_quality_score: Minimum quality score

        Returns:
            List of template metadata dictionaries
        """
        templates = []

        try:
            for template_file in self.storage_path.glob("*.json"):
                try:
                    with open(template_file) as f:
                        template_data = json.load(f)

                    metadata = template_data.get("metadata", {})

                    # Apply filters
                    if language and metadata.get("language") != language:
                        continue

                    if category and metadata.get("category") != category:
                        continue

                    if min_quality_score and metadata.get("quality_score", 0) < min_quality_score:
                        continue

                    templates.append(template_data)

                except Exception as e:
                    logger.warning("failed_to_load_template", file=str(template_file), error=str(e))
                    continue

            logger.info("json_templates_listed", count=len(templates))
            return templates

        except Exception as e:
            logger.error("list_json_templates_error", error=str(e))
            return []

    async def get_json_template(self, template_id: str) -> Optional[Dict[str, Any]]:
        """
        Get specific JSON template by ID.

        Args:
            template_id: Template UUID

        Returns:
            Template data or None
        """
        try:
            template_file = self.storage_path / f"{template_id}.json"

            if not template_file.exists():
                return None

            with open(template_file) as f:
                return json.load(f)

        except Exception as e:
            logger.error("get_json_template_error", template_id=template_id, error=str(e))
            return None

    async def register_json_template_to_db(
        self,
        template_data: Dict[str, Any],
        db_pool
    ) -> Optional[UUID]:
        """
        Register JSON template into PostgreSQL database.

        Args:
            template_data: Complete template data from JSON file
            db_pool: Database connection pool

        Returns:
            Template ID (UUID) if successful, None otherwise
        """
        try:
            metadata = template_data.get("metadata", {})

            # Extract fields
            template_id = UUID(metadata.get("id"))
            name = metadata.get("name")
            description = metadata.get("description", "")
            category = metadata.get("category", "general")
            language = metadata.get("language", "unknown")
            framework = metadata.get("framework")
            version = metadata.get("version", "1.0.0")
            tags = metadata.get("tags", [])
            organization = metadata.get("organization") or metadata.get("created_by", "maestro")

            # Quality scores
            quality_score = metadata.get("quality_score")
            security_score = metadata.get("security_score")
            performance_score = metadata.get("performance_score")
            maintainability_score = metadata.get("maintainability_score")

            # Workflow context
            workflow_context = template_data.get("workflow_context", {})
            quality_validation = template_data.get("quality_validation", {})

            # Additional metadata
            complexity = metadata.get("complexity", "intermediate")
            test_coverage = quality_validation.get("test_coverage", 0.0)

            # Check if already exists
            async with db_pool.acquire() as conn:
                existing = await conn.fetchrow(
                    "SELECT id FROM templates WHERE id = $1",
                    template_id
                )

                if existing:
                    logger.info("template_already_registered", template_id=str(template_id))
                    return template_id

                # Insert into database
                await conn.execute(
                    """
                    INSERT INTO templates (
                        id, name, description, category, language, framework, version,
                        tags, organization, templating_engine, manifest_validated,
                        manifest_validation_date, quality_score, security_score,
                        performance_score, maintainability_score, status,
                        created_by, created_at, updated_at
                    ) VALUES (
                        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, NOW(), NOW()
                    )
                    """,
                    template_id,
                    name,
                    description,
                    category,
                    language,
                    framework,
                    version,
                    tags,
                    organization,
                    'jinja2',  # Default templating engine
                    True,  # Validated by maestro-engine workflow
                    datetime.utcnow(),
                    quality_score,
                    security_score,
                    performance_score,
                    maintainability_score,
                    metadata.get("status", "approved"),
                    metadata.get("created_by", "maestro-engine")
                )

                logger.info(
                    "json_template_registered",
                    template_id=str(template_id),
                    name=name,
                    quality_score=quality_score
                )

                return template_id

        except Exception as e:
            logger.error("register_json_template_error", error=str(e))
            return None

    async def sync_all_json_templates_to_db(self, db_pool) -> Dict[str, int]:
        """
        Sync all JSON templates to database.

        Args:
            db_pool: Database connection pool

        Returns:
            Statistics dictionary with counts
        """
        stats = {
            "total": 0,
            "registered": 0,
            "skipped": 0,
            "failed": 0
        }

        try:
            templates = await self.list_json_templates()
            stats["total"] = len(templates)

            for template_data in templates:
                result = await self.register_json_template_to_db(template_data, db_pool)

                if result:
                    stats["registered"] += 1
                else:
                    # Check if it was skipped (already exists) or failed
                    metadata = template_data.get("metadata", {})
                    template_id = metadata.get("id")

                    async with db_pool.acquire() as conn:
                        existing = await conn.fetchrow(
                            "SELECT id FROM templates WHERE id = $1",
                            UUID(template_id)
                        )

                    if existing:
                        stats["skipped"] += 1
                    else:
                        stats["failed"] += 1

            logger.info("json_sync_complete", **stats)
            return stats

        except Exception as e:
            logger.error("sync_json_templates_error", error=str(e))
            return stats

    async def get_json_template_stats(self) -> Dict[str, Any]:
        """
        Get statistics about JSON template storage.

        Returns:
            Statistics dictionary
        """
        try:
            templates = await self.list_json_templates()

            stats = {
                "total_templates": len(templates),
                "by_language": {},
                "by_category": {},
                "by_complexity": {},
                "quality_distribution": {
                    "excellent": 0,  # >= 90
                    "good": 0,       # >= 80
                    "fair": 0,       # >= 70
                    "poor": 0        # < 70
                },
                "average_quality_score": 0.0,
                "average_test_coverage": 0.0
            }

            total_quality = 0.0
            total_coverage = 0.0

            for template in templates:
                metadata = template.get("metadata", {})

                # Language distribution
                language = metadata.get("language", "unknown")
                stats["by_language"][language] = stats["by_language"].get(language, 0) + 1

                # Category distribution
                category = metadata.get("category", "general")
                stats["by_category"][category] = stats["by_category"].get(category, 0) + 1

                # Complexity distribution
                complexity = metadata.get("complexity", "intermediate")
                stats["by_complexity"][complexity] = stats["by_complexity"].get(complexity, 0) + 1

                # Quality distribution
                quality_score = metadata.get("quality_score", 0)
                total_quality += quality_score

                if quality_score >= 90:
                    stats["quality_distribution"]["excellent"] += 1
                elif quality_score >= 80:
                    stats["quality_distribution"]["good"] += 1
                elif quality_score >= 70:
                    stats["quality_distribution"]["fair"] += 1
                else:
                    stats["quality_distribution"]["poor"] += 1

                # Test coverage
                quality_validation = template.get("quality_validation", {})
                coverage = quality_validation.get("test_coverage", 0)
                total_coverage += coverage

            # Calculate averages
            if templates:
                stats["average_quality_score"] = total_quality / len(templates)
                stats["average_test_coverage"] = total_coverage / len(templates)

            return stats

        except Exception as e:
            logger.error("get_json_stats_error", error=str(e))
            return {}


async def sync_json_storage_to_registry(db_pool):
    """
    Convenience function to sync JSON storage to database.

    Args:
        db_pool: Database connection pool

    Returns:
        Sync statistics
    """
    adapter = JSONStorageAdapter()
    return await adapter.sync_all_json_templates_to_db(db_pool)


if __name__ == "__main__":
    # Standalone testing
    import asyncio
    import asyncpg

    async def main():
        # Initialize database
        db_pool = await asyncpg.create_pool(
            "postgresql://maestro_template_user:maestro_template_pass@localhost:5432/maestro_templates"
        )

        # Create adapter
        adapter = JSONStorageAdapter()

        # Get stats
        print("\n=== JSON Template Storage Statistics ===")
        stats = await adapter.get_json_template_stats()
        print(json.dumps(stats, indent=2))

        # Sync to database
        print("\n=== Syncing to Database ===")
        sync_stats = await adapter.sync_all_json_templates_to_db(db_pool)
        print(f"Total: {sync_stats['total']}")
        print(f"Registered: {sync_stats['registered']}")
        print(f"Skipped: {sync_stats['skipped']}")
        print(f"Failed: {sync_stats['failed']}")

        # Cleanup
        await db_pool.close()

    asyncio.run(main())